//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `IIFServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <IIFServer.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_lbto_IIFServer_ids[2] =
{
    "::Ice::Object",
    "::lbto::IIFServer"
};
const ::std::string iceC_lbto_IIFServer_ops[] =
{
    "AcquireRefAO",
    "ApplyWaffleAO",
    "Authorize",
    "BinocularControl",
    "CheckRefAO",
    "ClearHotspot",
    "ClearNonSidereal",
    "ClearNonSiderealObject",
    "ClearOffset",
    "ClearReference",
    "ClearStars",
    "CorrectModesAO",
    "GetKFPCoordinates",
    "GetKFPCoordinates2",
    "GetKFPCoordinatesNew",
    "GetParameter",
    "GetRotatorPolynomials",
    "GetRotatorTrajectory",
    "LogEvent",
    "MaximizeWrapTime",
    "ModifyAO",
    "Move",
    "MoveFocus",
    "MoveXY",
    "MoveXYZ",
    "NSQuery",
    "OffsetGuiding",
    "OffsetPointing",
    "OffsetPointing2",
    "OffsetXYAO",
    "OffsetZAO",
    "PauseAO",
    "PauseGuiding",
    "PresetAO",
    "PresetFlatAO",
    "PresetTelescope",
    "RefineAO",
    "ResumeAO",
    "ResumeGuiding",
    "RotHold",
    "RotReady",
    "RotServicePosition",
    "RotTrack",
    "RotateCommon",
    "RotatePrimary",
    "RotateZ",
    "RunAO",
    "SendWavefront",
    "SetAGWFilter",
    "SetGuidingBinning",
    "SetGuidingHotspot",
    "SetHotspot",
    "SetNonSidereal",
    "SetNonSiderealObject",
    "SetOffset",
    "SetOffset2",
    "SetOffsetNew",
    "SetPMTerm",
    "SetPMTerm2",
    "SetParameter",
    "SetReference",
    "SetReference2",
    "SetReferenceNew",
    "SetStars",
    "SetStars2",
    "SetStarsNew",
    "SetTarget",
    "Standby",
    "StartAO",
    "StepFocus",
    "StopAO",
    "StopGuiding",
    "TipTilt",
    "UpdateNonSiderealObject",
    "UpdateNonSiderealTarget",
    "UpdatePointingReference",
    "UpdateTargetWavelength",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "remove"
};
const ::std::string iceC_lbto_IIFServer_ApplyWaffleAO_name = "ApplyWaffleAO";
const ::std::string iceC_lbto_IIFServer_Authorize_name = "Authorize";
const ::std::string iceC_lbto_IIFServer_StepFocus_name = "StepFocus";
const ::std::string iceC_lbto_IIFServer_MoveFocus_name = "MoveFocus";
const ::std::string iceC_lbto_IIFServer_OffsetPointing_name = "OffsetPointing";
const ::std::string iceC_lbto_IIFServer_OffsetPointing2_name = "OffsetPointing2";
const ::std::string iceC_lbto_IIFServer_OffsetGuiding_name = "OffsetGuiding";
const ::std::string iceC_lbto_IIFServer_UpdatePointingReference_name = "UpdatePointingReference";
const ::std::string iceC_lbto_IIFServer_TipTilt_name = "TipTilt";
const ::std::string iceC_lbto_IIFServer_SetPMTerm_name = "SetPMTerm";
const ::std::string iceC_lbto_IIFServer_SetPMTerm2_name = "SetPMTerm2";
const ::std::string iceC_lbto_IIFServer_MoveXYZ_name = "MoveXYZ";
const ::std::string iceC_lbto_IIFServer_MoveXY_name = "MoveXY";
const ::std::string iceC_lbto_IIFServer_Move_name = "Move";
const ::std::string iceC_lbto_IIFServer_SetTarget_name = "SetTarget";
const ::std::string iceC_lbto_IIFServer_SetStars_name = "SetStars";
const ::std::string iceC_lbto_IIFServer_SetStarsNew_name = "SetStarsNew";
const ::std::string iceC_lbto_IIFServer_SetStars2_name = "SetStars2";
const ::std::string iceC_lbto_IIFServer_ClearStars_name = "ClearStars";
const ::std::string iceC_lbto_IIFServer_SetHotspot_name = "SetHotspot";
const ::std::string iceC_lbto_IIFServer_ClearHotspot_name = "ClearHotspot";
const ::std::string iceC_lbto_IIFServer_SetOffset_name = "SetOffset";
const ::std::string iceC_lbto_IIFServer_SetOffsetNew_name = "SetOffsetNew";
const ::std::string iceC_lbto_IIFServer_SetOffset2_name = "SetOffset2";
const ::std::string iceC_lbto_IIFServer_ClearOffset_name = "ClearOffset";
const ::std::string iceC_lbto_IIFServer_SetNonSidereal_name = "SetNonSidereal";
const ::std::string iceC_lbto_IIFServer_ClearNonSidereal_name = "ClearNonSidereal";
const ::std::string iceC_lbto_IIFServer_UpdateNonSiderealTarget_name = "UpdateNonSiderealTarget";
const ::std::string iceC_lbto_IIFServer_SetNonSiderealObject_name = "SetNonSiderealObject";
const ::std::string iceC_lbto_IIFServer_ClearNonSiderealObject_name = "ClearNonSiderealObject";
const ::std::string iceC_lbto_IIFServer_UpdateNonSiderealObject_name = "UpdateNonSiderealObject";
const ::std::string iceC_lbto_IIFServer_PresetTelescope_name = "PresetTelescope";
const ::std::string iceC_lbto_IIFServer_BinocularControl_name = "BinocularControl";
const ::std::string iceC_lbto_IIFServer_GetParameter_name = "GetParameter";
const ::std::string iceC_lbto_IIFServer_SetParameter_name = "SetParameter";
const ::std::string iceC_lbto_IIFServer_RotateCommon_name = "RotateCommon";
const ::std::string iceC_lbto_IIFServer_RotateZ_name = "RotateZ";
const ::std::string iceC_lbto_IIFServer_RotatePrimary_name = "RotatePrimary";
const ::std::string iceC_lbto_IIFServer_SendWavefront_name = "SendWavefront";
const ::std::string iceC_lbto_IIFServer_UpdateTargetWavelength_name = "UpdateTargetWavelength";
const ::std::string iceC_lbto_IIFServer_LogEvent_name = "LogEvent";
const ::std::string iceC_lbto_IIFServer_GetRotatorTrajectory_name = "GetRotatorTrajectory";
const ::std::string iceC_lbto_IIFServer_GetRotatorPolynomials_name = "GetRotatorPolynomials";
const ::std::string iceC_lbto_IIFServer_Standby_name = "Standby";
const ::std::string iceC_lbto_IIFServer_MaximizeWrapTime_name = "MaximizeWrapTime";
const ::std::string iceC_lbto_IIFServer_PauseGuiding_name = "PauseGuiding";
const ::std::string iceC_lbto_IIFServer_ResumeGuiding_name = "ResumeGuiding";
const ::std::string iceC_lbto_IIFServer_StopGuiding_name = "StopGuiding";
const ::std::string iceC_lbto_IIFServer_SetGuidingHotspot_name = "SetGuidingHotspot";
const ::std::string iceC_lbto_IIFServer_SetAGWFilter_name = "SetAGWFilter";
const ::std::string iceC_lbto_IIFServer_SetGuidingBinning_name = "SetGuidingBinning";
const ::std::string iceC_lbto_IIFServer_RotReady_name = "RotReady";
const ::std::string iceC_lbto_IIFServer_RotHold_name = "RotHold";
const ::std::string iceC_lbto_IIFServer_RotTrack_name = "RotTrack";
const ::std::string iceC_lbto_IIFServer_RotServicePosition_name = "RotServicePosition";
const ::std::string iceC_lbto_IIFServer_PauseAO_name = "PauseAO";
const ::std::string iceC_lbto_IIFServer_ResumeAO_name = "ResumeAO";
const ::std::string iceC_lbto_IIFServer_StartAO_name = "StartAO";
const ::std::string iceC_lbto_IIFServer_StopAO_name = "StopAO";
const ::std::string iceC_lbto_IIFServer_AcquireRefAO_name = "AcquireRefAO";
const ::std::string iceC_lbto_IIFServer_CheckRefAO_name = "CheckRefAO";
const ::std::string iceC_lbto_IIFServer_RefineAO_name = "RefineAO";
const ::std::string iceC_lbto_IIFServer_RunAO_name = "RunAO";
const ::std::string iceC_lbto_IIFServer_PresetFlatAO_name = "PresetFlatAO";
const ::std::string iceC_lbto_IIFServer_CorrectModesAO_name = "CorrectModesAO";
const ::std::string iceC_lbto_IIFServer_ModifyAO_name = "ModifyAO";
const ::std::string iceC_lbto_IIFServer_PresetAO_name = "PresetAO";
const ::std::string iceC_lbto_IIFServer_OffsetXYAO_name = "OffsetXYAO";
const ::std::string iceC_lbto_IIFServer_OffsetZAO_name = "OffsetZAO";
const ::std::string iceC_lbto_IIFServer_SetReference_name = "SetReference";
const ::std::string iceC_lbto_IIFServer_SetReferenceNew_name = "SetReferenceNew";
const ::std::string iceC_lbto_IIFServer_SetReference2_name = "SetReference2";
const ::std::string iceC_lbto_IIFServer_ClearReference_name = "ClearReference";
const ::std::string iceC_lbto_IIFServer_GetKFPCoordinates_name = "GetKFPCoordinates";
const ::std::string iceC_lbto_IIFServer_GetKFPCoordinatesNew_name = "GetKFPCoordinatesNew";
const ::std::string iceC_lbto_IIFServer_GetKFPCoordinates2_name = "GetKFPCoordinates2";
const ::std::string iceC_lbto_IIFServer_NSQuery_name = "NSQuery";
const ::std::string iceC_lbto_IIFServer_remove_name = "remove";

}

bool
lbto::IIFServer::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_lbto_IIFServer_ids, iceC_lbto_IIFServer_ids + 2, s);
}

::std::vector<::std::string>
lbto::IIFServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_lbto_IIFServer_ids[0], &iceC_lbto_IIFServer_ids[2]);
}

::std::string
lbto::IIFServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
lbto::IIFServer::ice_staticId()
{
    static const ::std::string typeId = "::lbto::IIFServer";
    return typeId;
}

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ApplyWaffleAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqModes iceP_modes;
    ::std::string iceP_side;
    istr->readAll(iceP_modes, iceP_side);
    inS.endReadParams();
    iifres ret = this->ApplyWaffleAO(::std::move(iceP_modes), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Authorize(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->Authorize(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StepFocus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_relPos;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->readAll(iceP_relPos, iceP_ope, iceP_side);
    inS.endReadParams();
    iifres ret = this->StepFocus(iceP_relPos, ::std::move(iceP_ope), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveFocus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_absPos;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->readAll(iceP_absPos, iceP_ope, iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveFocus(iceP_absPos, ::std::move(iceP_ope), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetPointing(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_rotangle;
    double iceP_offx;
    double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_ope;
    ::std::string iceP_np;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->readAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_ope, iceP_np, iceP_movetype, iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetPointing(iceP_rotangle, iceP_offx, iceP_offy, ::std::move(iceP_coordsys), ::std::move(iceP_ope), ::std::move(iceP_np), ::std::move(iceP_movetype), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetPointing2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_rotangle;
    double iceP_offx;
    double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->readAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_movetype, iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetPointing2(iceP_rotangle, iceP_offx, iceP_offy, ::std::move(iceP_coordsys), ::std::move(iceP_movetype), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_rotangle;
    double iceP_offx;
    double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_side;
    istr->readAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetGuiding(iceP_rotangle, iceP_offx, iceP_offy, ::std::move(iceP_coordsys), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdatePointingReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_offsetcoord;
    ::std::string iceP_side;
    istr->readAll(iceP_offsetcoord, iceP_side);
    inS.endReadParams();
    iifres ret = this->UpdatePointingReference(::std::move(iceP_offsetcoord), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_TipTilt(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_xrot;
    double iceP_yrot;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->readAll(iceP_xrot, iceP_yrot, iceP_ope, iceP_side);
    inS.endReadParams();
    iifres ret = this->TipTilt(iceP_xrot, iceP_yrot, ::std::move(iceP_ope), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetPMTerm(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    double iceP_value;
    ::std::string iceP_side;
    istr->readAll(iceP_name, iceP_value, iceP_side);
    inS.endReadParams();
    iifres ret = this->SetPMTerm(::std::move(iceP_name), iceP_value, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetPMTerm2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    double iceP_value;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->readAll(iceP_name, iceP_value, iceP_movetype, iceP_side);
    inS.endReadParams();
    iifres ret = this->SetPMTerm2(::std::move(iceP_name), iceP_value, ::std::move(iceP_movetype), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveXYZ(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_xmov;
    double iceP_ymov;
    double iceP_zmov;
    ::std::string iceP_side;
    istr->readAll(iceP_xmov, iceP_ymov, iceP_zmov, iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveXYZ(iceP_xmov, iceP_ymov, iceP_zmov, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveXY(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_xmov;
    double iceP_ymov;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->readAll(iceP_xmov, iceP_ymov, iceP_ope, iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveXY(iceP_xmov, iceP_ymov, ::std::move(iceP_ope), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Move(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_x;
    double iceP_y;
    double iceP_z;
    double iceP_rx;
    double iceP_ry;
    double iceP_rz;
    int iceP_dflag;
    ::std::string iceP_movetype;
    ::std::string iceP_OPE;
    int iceP_time;
    ::std::string iceP_side;
    istr->readAll(iceP_x, iceP_y, iceP_z, iceP_rx, iceP_ry, iceP_rz, iceP_dflag, iceP_movetype, iceP_OPE, iceP_time, iceP_side);
    inS.endReadParams();
    iifres ret = this->Move(iceP_x, iceP_y, iceP_z, iceP_rx, iceP_ry, iceP_rz, iceP_dflag, ::std::move(iceP_movetype), ::std::move(iceP_OPE), iceP_time, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetTarget(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    ::std::string iceP_system;
    double iceP_epoch;
    float iceP_wavelength;
    istr->readAll(iceP_coord1, iceP_coord2, iceP_system, iceP_epoch, iceP_wavelength);
    inS.endReadParams();
    iifres ret = this->SetTarget(iceP_coord1, iceP_coord2, ::std::move(iceP_system), iceP_epoch, iceP_wavelength, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStars(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStars(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStarsNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStarsNew(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStars2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStars2(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearStars(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearStars(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    istr->readAll(iceP_coord1, iceP_coord2);
    inS.endReadParams();
    iifres ret = this->SetHotspot(iceP_coord1, iceP_coord2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearHotspot(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    ::std::string iceP_system;
    istr->readAll(iceP_coord1, iceP_coord2, iceP_system);
    inS.endReadParams();
    iifres ret = this->SetOffset(iceP_coord1, iceP_coord2, ::std::move(iceP_system), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffsetNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    ::std::string iceP_system;
    ::std::string iceP_movetype;
    istr->readAll(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype);
    inS.endReadParams();
    iifres ret = this->SetOffsetNew(iceP_coord1, iceP_coord2, ::std::move(iceP_system), ::std::move(iceP_movetype), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffset2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    ::std::string iceP_system;
    ::std::string iceP_movetype;
    istr->readAll(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype);
    inS.endReadParams();
    iifres ret = this->SetOffset2(iceP_coord1, iceP_coord2, ::std::move(iceP_system), ::std::move(iceP_movetype), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearOffset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearOffset(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetNonSidereal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    nonsidereal iceP_target;
    bool iceP_override;
    istr->readAll(iceP_target, iceP_override);
    inS.endReadParams();
    iifres ret = this->SetNonSidereal(::std::move(iceP_target), iceP_override, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearNonSidereal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_override;
    istr->readAll(iceP_override);
    inS.endReadParams();
    iifres ret = this->ClearNonSidereal(iceP_override, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateNonSiderealTarget(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_RArate;
    double iceP_DECrate;
    istr->readAll(iceP_RArate, iceP_DECrate);
    inS.endReadParams();
    iifres ret = this->UpdateNonSiderealTarget(iceP_RArate, iceP_DECrate, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_objtype;
    nonsidereal iceP_target;
    bool iceP_override;
    istr->readAll(iceP_objtype, iceP_target, iceP_override);
    inS.endReadParams();
    iifres ret = this->SetNonSiderealObject(::std::move(iceP_objtype), ::std::move(iceP_target), iceP_override, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_objtype;
    bool iceP_override;
    istr->readAll(iceP_objtype, iceP_override);
    inS.endReadParams();
    iifres ret = this->ClearNonSiderealObject(::std::move(iceP_objtype), iceP_override, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_objtype;
    double iceP_RArate;
    double iceP_DECrate;
    istr->readAll(iceP_objtype, iceP_RArate, iceP_DECrate);
    inS.endReadParams();
    iifres ret = this->UpdateNonSiderealObject(::std::move(iceP_objtype), iceP_RArate, iceP_DECrate, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetTelescope(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_rotangle;
    ::std::string iceP_rotmode;
    ::std::string iceP_mode;
    ::std::string iceP_side;
    istr->readAll(iceP_rotangle, iceP_rotmode, iceP_mode, iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetTelescope(iceP_rotangle, ::std::move(iceP_rotmode), ::std::move(iceP_mode), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_BinocularControl(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_flag;
    istr->readAll(iceP_flag);
    inS.endReadParams();
    iifres ret = this->BinocularControl(::std::move(iceP_flag), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetParameter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqDD iceP_list;
    istr->readAll(iceP_list);
    inS.endReadParams();
    iifres ret = this->GetParameter(::std::move(iceP_list), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetParameter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqDD iceP_list;
    istr->readAll(iceP_list);
    inS.endReadParams();
    iifres ret = this->SetParameter(::std::move(iceP_list), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotateCommon(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_z;
    double iceP_angle;
    double iceP_direction;
    ::std::string iceP_side;
    istr->readAll(iceP_z, iceP_angle, iceP_direction, iceP_side);
    inS.endReadParams();
    iifres ret = this->RotateCommon(iceP_z, iceP_angle, iceP_direction, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotateZ(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_angle;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->readAll(iceP_angle, iceP_movetype, iceP_side);
    inS.endReadParams();
    iifres ret = this->RotateZ(iceP_angle, ::std::move(iceP_movetype), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotatePrimary(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_distance;
    double iceP_angle;
    double iceP_direction;
    ::std::string iceP_side;
    istr->readAll(iceP_distance, iceP_angle, iceP_direction, iceP_side);
    inS.endReadParams();
    iifres ret = this->RotatePrimary(iceP_distance, iceP_angle, iceP_direction, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SendWavefront(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqWF iceP_wfs;
    ::std::string iceP_OPE;
    ::std::string iceP_side;
    istr->readAll(iceP_wfs, iceP_OPE, iceP_side);
    inS.endReadParams();
    iifres ret = this->SendWavefront(::std::move(iceP_wfs), ::std::move(iceP_OPE), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateTargetWavelength(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    float iceP_wavelength;
    ::std::string iceP_side;
    istr->readAll(iceP_wavelength, iceP_side);
    inS.endReadParams();
    iifres ret = this->UpdateTargetWavelength(iceP_wavelength, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_LogEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_event;
    ::std::string iceP_description;
    istr->readAll(iceP_event, iceP_description);
    inS.endReadParams();
    iifres ret = this->LogEvent(::std::move(iceP_event), ::std::move(iceP_description), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetRotatorTrajectory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_seconds;
    double iceP_interval;
    double iceP_start;
    ::std::string iceP_side;
    istr->readAll(iceP_seconds, iceP_interval, iceP_start, iceP_side);
    inS.endReadParams();
    iifres ret = this->GetRotatorTrajectory(iceP_seconds, iceP_interval, iceP_start, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetRotatorPolynomials(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_start;
    int iceP_count;
    double iceP_interval;
    int iceP_order;
    ::std::string iceP_side;
    istr->readAll(iceP_start, iceP_count, iceP_interval, iceP_order, iceP_side);
    inS.endReadParams();
    iifres ret = this->GetRotatorPolynomials(iceP_start, iceP_count, iceP_interval, iceP_order, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Standby(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_level;
    ::std::string iceP_side;
    istr->readAll(iceP_level, iceP_side);
    inS.endReadParams();
    iifres ret = this->Standby(iceP_level, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MaximizeWrapTime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_azflag;
    bool iceP_rotflag;
    ::std::string iceP_side;
    istr->readAll(iceP_azflag, iceP_rotflag, iceP_side);
    inS.endReadParams();
    iifres ret = this->MaximizeWrapTime(iceP_azflag, iceP_rotflag, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PauseGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->PauseGuiding(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ResumeGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->ResumeGuiding(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StopGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->StopGuiding(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetGuidingHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_coord1;
    double iceP_coord2;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->readAll(iceP_coord1, iceP_coord2, iceP_movetype, iceP_side);
    inS.endReadParams();
    iifres ret = this->SetGuidingHotspot(iceP_coord1, iceP_coord2, ::std::move(iceP_movetype), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetAGWFilter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_filterNumber;
    ::std::string iceP_side;
    istr->readAll(iceP_filterNumber, iceP_side);
    inS.endReadParams();
    iifres ret = this->SetAGWFilter(iceP_filterNumber, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetGuidingBinning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_factor;
    ::std::string iceP_side;
    istr->readAll(iceP_factor, iceP_side);
    inS.endReadParams();
    iifres ret = this->SetGuidingBinning(iceP_factor, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotReady(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_enable;
    ::std::string iceP_side;
    istr->readAll(iceP_enable, iceP_side);
    inS.endReadParams();
    iifres ret = this->RotReady(iceP_enable, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotHold(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotHold(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotTrack(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotTrack(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotServicePosition(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_angle;
    ::std::string iceP_side;
    istr->readAll(iceP_angle, iceP_side);
    inS.endReadParams();
    iifres ret = this->RotServicePosition(iceP_angle, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PauseAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->PauseAO(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ResumeAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->ResumeAO(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StartAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->StartAO(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StopAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_reason;
    ::std::string iceP_side;
    istr->readAll(iceP_reason, iceP_side);
    inS.endReadParams();
    iifres ret = this->StopAO(::std::move(iceP_reason), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_AcquireRefAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_repointFlag;
    ::std::string iceP_side;
    istr->readAll(iceP_repointFlag, iceP_side);
    inS.endReadParams();
    iifres ret = this->AcquireRefAO(iceP_repointFlag, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_CheckRefAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->readAll(iceP_side);
    inS.endReadParams();
    iifres ret = this->CheckRefAO(::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RefineAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_method;
    ::std::string iceP_side;
    istr->readAll(iceP_method, iceP_side);
    inS.endReadParams();
    iifres ret = this->RefineAO(::std::move(iceP_method), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RunAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_type;
    ::std::string iceP_side;
    istr->readAll(iceP_type, iceP_side);
    inS.endReadParams();
    iifres ret = this->RunAO(::std::move(iceP_type), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetFlatAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_flat;
    ::std::string iceP_side;
    istr->readAll(iceP_flat, iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetFlatAO(::std::move(iceP_flat), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_CorrectModesAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqModes iceP_modes;
    ::std::string iceP_side;
    istr->readAll(iceP_modes, iceP_side);
    inS.endReadParams();
    iifres ret = this->CorrectModesAO(::std::move(iceP_modes), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ModifyAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_NModes;
    double iceP_Freq;
    int iceP_Nbins;
    double iceP_TTMod;
    ::std::string iceP_F1spec;
    ::std::string iceP_F2spec;
    ::std::string iceP_side;
    istr->readAll(iceP_NModes, iceP_Freq, iceP_Nbins, iceP_TTMod, iceP_F1spec, iceP_F2spec, iceP_side);
    inS.endReadParams();
    iifres ret = this->ModifyAO(iceP_NModes, iceP_Freq, iceP_Nbins, iceP_TTMod, ::std::move(iceP_F1spec), ::std::move(iceP_F2spec), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_AOMode;
    ::std::string iceP_side;
    istr->readAll(iceP_AOMode, iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetAO(::std::move(iceP_AOMode), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetXYAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_DeltaX;
    double iceP_DeltaY;
    ::std::string iceP_side;
    istr->readAll(iceP_DeltaX, iceP_DeltaY, iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetXYAO(iceP_DeltaX, iceP_DeltaY, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetZAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_DeltaZ;
    ::std::string iceP_side;
    istr->readAll(iceP_DeltaZ, iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetZAO(iceP_DeltaZ, ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReference(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReferenceNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReferenceNew(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReference2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    istr->readAll(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReference2(::std::move(iceP_stars), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearReference(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinates(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos iceP_stars;
    ::std::string iceP_side;
    istr->readAll(iceP_stars, iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinates(::std::move(iceP_stars), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinatesNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    ::std::string iceP_side;
    istr->readAll(iceP_stars, iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinatesNew(::std::move(iceP_stars), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinates2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    ::std::string iceP_side;
    istr->readAll(iceP_stars, iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinates2(::std::move(iceP_stars), ::std::move(iceP_side), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_NSQuery(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_targenName;
    ::std::string iceP_startDate;
    ::std::string iceP_startTime;
    ::std::string iceP_endDate;
    ::std::string iceP_endTime;
    ::std::string iceP_interval;
    ::std::string iceP_fileName;
    istr->readAll(iceP_targenName, iceP_startDate, iceP_startTime, iceP_endDate, iceP_endTime, iceP_interval, iceP_fileName);
    inS.endReadParams();
    iifres ret = this->NSQuery(::std::move(iceP_targenName), ::std::move(iceP_startDate), ::std::move(iceP_startTime), ::std::move(iceP_endDate), ::std::move(iceP_endTime), ::std::move(iceP_interval), ::std::move(iceP_fileName), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_remove(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->remove(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_lbto_IIFServer_ops, iceC_lbto_IIFServer_ops + 82, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_lbto_IIFServer_ops)
    {
        case 0:
        {
            return _iceD_AcquireRefAO(in, current);
        }
        case 1:
        {
            return _iceD_ApplyWaffleAO(in, current);
        }
        case 2:
        {
            return _iceD_Authorize(in, current);
        }
        case 3:
        {
            return _iceD_BinocularControl(in, current);
        }
        case 4:
        {
            return _iceD_CheckRefAO(in, current);
        }
        case 5:
        {
            return _iceD_ClearHotspot(in, current);
        }
        case 6:
        {
            return _iceD_ClearNonSidereal(in, current);
        }
        case 7:
        {
            return _iceD_ClearNonSiderealObject(in, current);
        }
        case 8:
        {
            return _iceD_ClearOffset(in, current);
        }
        case 9:
        {
            return _iceD_ClearReference(in, current);
        }
        case 10:
        {
            return _iceD_ClearStars(in, current);
        }
        case 11:
        {
            return _iceD_CorrectModesAO(in, current);
        }
        case 12:
        {
            return _iceD_GetKFPCoordinates(in, current);
        }
        case 13:
        {
            return _iceD_GetKFPCoordinates2(in, current);
        }
        case 14:
        {
            return _iceD_GetKFPCoordinatesNew(in, current);
        }
        case 15:
        {
            return _iceD_GetParameter(in, current);
        }
        case 16:
        {
            return _iceD_GetRotatorPolynomials(in, current);
        }
        case 17:
        {
            return _iceD_GetRotatorTrajectory(in, current);
        }
        case 18:
        {
            return _iceD_LogEvent(in, current);
        }
        case 19:
        {
            return _iceD_MaximizeWrapTime(in, current);
        }
        case 20:
        {
            return _iceD_ModifyAO(in, current);
        }
        case 21:
        {
            return _iceD_Move(in, current);
        }
        case 22:
        {
            return _iceD_MoveFocus(in, current);
        }
        case 23:
        {
            return _iceD_MoveXY(in, current);
        }
        case 24:
        {
            return _iceD_MoveXYZ(in, current);
        }
        case 25:
        {
            return _iceD_NSQuery(in, current);
        }
        case 26:
        {
            return _iceD_OffsetGuiding(in, current);
        }
        case 27:
        {
            return _iceD_OffsetPointing(in, current);
        }
        case 28:
        {
            return _iceD_OffsetPointing2(in, current);
        }
        case 29:
        {
            return _iceD_OffsetXYAO(in, current);
        }
        case 30:
        {
            return _iceD_OffsetZAO(in, current);
        }
        case 31:
        {
            return _iceD_PauseAO(in, current);
        }
        case 32:
        {
            return _iceD_PauseGuiding(in, current);
        }
        case 33:
        {
            return _iceD_PresetAO(in, current);
        }
        case 34:
        {
            return _iceD_PresetFlatAO(in, current);
        }
        case 35:
        {
            return _iceD_PresetTelescope(in, current);
        }
        case 36:
        {
            return _iceD_RefineAO(in, current);
        }
        case 37:
        {
            return _iceD_ResumeAO(in, current);
        }
        case 38:
        {
            return _iceD_ResumeGuiding(in, current);
        }
        case 39:
        {
            return _iceD_RotHold(in, current);
        }
        case 40:
        {
            return _iceD_RotReady(in, current);
        }
        case 41:
        {
            return _iceD_RotServicePosition(in, current);
        }
        case 42:
        {
            return _iceD_RotTrack(in, current);
        }
        case 43:
        {
            return _iceD_RotateCommon(in, current);
        }
        case 44:
        {
            return _iceD_RotatePrimary(in, current);
        }
        case 45:
        {
            return _iceD_RotateZ(in, current);
        }
        case 46:
        {
            return _iceD_RunAO(in, current);
        }
        case 47:
        {
            return _iceD_SendWavefront(in, current);
        }
        case 48:
        {
            return _iceD_SetAGWFilter(in, current);
        }
        case 49:
        {
            return _iceD_SetGuidingBinning(in, current);
        }
        case 50:
        {
            return _iceD_SetGuidingHotspot(in, current);
        }
        case 51:
        {
            return _iceD_SetHotspot(in, current);
        }
        case 52:
        {
            return _iceD_SetNonSidereal(in, current);
        }
        case 53:
        {
            return _iceD_SetNonSiderealObject(in, current);
        }
        case 54:
        {
            return _iceD_SetOffset(in, current);
        }
        case 55:
        {
            return _iceD_SetOffset2(in, current);
        }
        case 56:
        {
            return _iceD_SetOffsetNew(in, current);
        }
        case 57:
        {
            return _iceD_SetPMTerm(in, current);
        }
        case 58:
        {
            return _iceD_SetPMTerm2(in, current);
        }
        case 59:
        {
            return _iceD_SetParameter(in, current);
        }
        case 60:
        {
            return _iceD_SetReference(in, current);
        }
        case 61:
        {
            return _iceD_SetReference2(in, current);
        }
        case 62:
        {
            return _iceD_SetReferenceNew(in, current);
        }
        case 63:
        {
            return _iceD_SetStars(in, current);
        }
        case 64:
        {
            return _iceD_SetStars2(in, current);
        }
        case 65:
        {
            return _iceD_SetStarsNew(in, current);
        }
        case 66:
        {
            return _iceD_SetTarget(in, current);
        }
        case 67:
        {
            return _iceD_Standby(in, current);
        }
        case 68:
        {
            return _iceD_StartAO(in, current);
        }
        case 69:
        {
            return _iceD_StepFocus(in, current);
        }
        case 70:
        {
            return _iceD_StopAO(in, current);
        }
        case 71:
        {
            return _iceD_StopGuiding(in, current);
        }
        case 72:
        {
            return _iceD_TipTilt(in, current);
        }
        case 73:
        {
            return _iceD_UpdateNonSiderealObject(in, current);
        }
        case 74:
        {
            return _iceD_UpdateNonSiderealTarget(in, current);
        }
        case 75:
        {
            return _iceD_UpdatePointingReference(in, current);
        }
        case 76:
        {
            return _iceD_UpdateTargetWavelength(in, current);
        }
        case 77:
        {
            return _iceD_ice_id(in, current);
        }
        case 78:
        {
            return _iceD_ice_ids(in, current);
        }
        case 79:
        {
            return _iceD_ice_isA(in, current);
        }
        case 80:
        {
            return _iceD_ice_ping(in, current);
        }
        case 81:
        {
            return _iceD_remove(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ApplyWaffleAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqModes& iceP_modes, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ApplyWaffleAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_ApplyWaffleAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_modes, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_Authorize(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Authorize_name);
    outAsync->invoke(iceC_lbto_IIFServer_Authorize_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_StepFocus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_relPos, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StepFocus_name);
    outAsync->invoke(iceC_lbto_IIFServer_StepFocus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_relPos, iceP_ope, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_MoveFocus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_absPos, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveFocus_name);
    outAsync->invoke(iceC_lbto_IIFServer_MoveFocus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_absPos, iceP_ope, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_OffsetPointing(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_rotangle, double iceP_offx, double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_ope, const ::std::string& iceP_np, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetPointing_name);
    outAsync->invoke(iceC_lbto_IIFServer_OffsetPointing_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_ope, iceP_np, iceP_movetype, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_OffsetPointing2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_rotangle, double iceP_offx, double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetPointing2_name);
    outAsync->invoke(iceC_lbto_IIFServer_OffsetPointing2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_movetype, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_OffsetGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_rotangle, double iceP_offx, double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetGuiding_name);
    outAsync->invoke(iceC_lbto_IIFServer_OffsetGuiding_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_UpdatePointingReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_offsetcoord, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdatePointingReference_name);
    outAsync->invoke(iceC_lbto_IIFServer_UpdatePointingReference_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_offsetcoord, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_TipTilt(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_xrot, double iceP_yrot, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_TipTilt_name);
    outAsync->invoke(iceC_lbto_IIFServer_TipTilt_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_xrot, iceP_yrot, iceP_ope, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetPMTerm(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_name, double iceP_value, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetPMTerm_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetPMTerm_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_value, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetPMTerm2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_name, double iceP_value, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetPMTerm2_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetPMTerm2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_value, iceP_movetype, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_MoveXYZ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_xmov, double iceP_ymov, double iceP_zmov, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveXYZ_name);
    outAsync->invoke(iceC_lbto_IIFServer_MoveXYZ_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_xmov, iceP_ymov, iceP_zmov, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_MoveXY(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_xmov, double iceP_ymov, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveXY_name);
    outAsync->invoke(iceC_lbto_IIFServer_MoveXY_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_xmov, iceP_ymov, iceP_ope, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_Move(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_x, double iceP_y, double iceP_z, double iceP_rx, double iceP_ry, double iceP_rz, int iceP_dflag, const ::std::string& iceP_movetype, const ::std::string& iceP_OPE, int iceP_time, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Move_name);
    outAsync->invoke(iceC_lbto_IIFServer_Move_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_x, iceP_y, iceP_z, iceP_rx, iceP_ry, iceP_rz, iceP_dflag, iceP_movetype, iceP_OPE, iceP_time, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::std::string& iceP_system, double iceP_epoch, float iceP_wavelength, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetTarget_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetTarget_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2, iceP_system, iceP_epoch, iceP_wavelength);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetStars(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStars_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetStars_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetStarsNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqNewPos& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStarsNew_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetStarsNew_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetStars2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos2& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStars2_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetStars2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearStars(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearStars_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearStars_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetHotspot_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetHotspot_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearHotspot_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearHotspot_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetOffset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::std::string& iceP_system, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffset_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetOffset_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2, iceP_system);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetOffsetNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::std::string& iceP_system, const ::std::string& iceP_movetype, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffsetNew_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetOffsetNew_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetOffset2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::std::string& iceP_system, const ::std::string& iceP_movetype, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffset2_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetOffset2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearOffset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearOffset_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearOffset_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetNonSidereal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const nonsidereal& iceP_target, bool iceP_override, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetNonSidereal_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetNonSidereal_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_target, iceP_override);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearNonSidereal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, bool iceP_override, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearNonSidereal_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearNonSidereal_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_override);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_UpdateNonSiderealTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_RArate, double iceP_DECrate, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateNonSiderealTarget_name);
    outAsync->invoke(iceC_lbto_IIFServer_UpdateNonSiderealTarget_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_RArate, iceP_DECrate);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_objtype, const nonsidereal& iceP_target, bool iceP_override, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetNonSiderealObject_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetNonSiderealObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_objtype, iceP_target, iceP_override);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_objtype, bool iceP_override, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearNonSiderealObject_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearNonSiderealObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_objtype, iceP_override);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_UpdateNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_objtype, double iceP_RArate, double iceP_DECrate, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateNonSiderealObject_name);
    outAsync->invoke(iceC_lbto_IIFServer_UpdateNonSiderealObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_objtype, iceP_RArate, iceP_DECrate);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_PresetTelescope(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_rotangle, const ::std::string& iceP_rotmode, const ::std::string& iceP_mode, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetTelescope_name);
    outAsync->invoke(iceC_lbto_IIFServer_PresetTelescope_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_rotangle, iceP_rotmode, iceP_mode, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_BinocularControl(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_flag, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_BinocularControl_name);
    outAsync->invoke(iceC_lbto_IIFServer_BinocularControl_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_flag);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetParameter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqDD& iceP_list, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetParameter_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetParameter_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_list);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetParameter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqDD& iceP_list, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetParameter_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetParameter_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_list);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotateCommon(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_z, double iceP_angle, double iceP_direction, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotateCommon_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotateCommon_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_z, iceP_angle, iceP_direction, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotateZ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_angle, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotateZ_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotateZ_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_angle, iceP_movetype, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotatePrimary(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_distance, double iceP_angle, double iceP_direction, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotatePrimary_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotatePrimary_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_distance, iceP_angle, iceP_direction, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SendWavefront(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqWF& iceP_wfs, const ::std::string& iceP_OPE, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SendWavefront_name);
    outAsync->invoke(iceC_lbto_IIFServer_SendWavefront_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_wfs, iceP_OPE, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_UpdateTargetWavelength(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, float iceP_wavelength, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateTargetWavelength_name);
    outAsync->invoke(iceC_lbto_IIFServer_UpdateTargetWavelength_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_wavelength, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_LogEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_event, const ::std::string& iceP_description, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_LogEvent_name);
    outAsync->invoke(iceC_lbto_IIFServer_LogEvent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_event, iceP_description);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetRotatorTrajectory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_seconds, double iceP_interval, double iceP_start, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetRotatorTrajectory_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetRotatorTrajectory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_seconds, iceP_interval, iceP_start, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetRotatorPolynomials(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_start, int iceP_count, double iceP_interval, int iceP_order, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetRotatorPolynomials_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetRotatorPolynomials_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_start, iceP_count, iceP_interval, iceP_order, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_Standby(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, int iceP_level, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Standby_name);
    outAsync->invoke(iceC_lbto_IIFServer_Standby_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_level, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_MaximizeWrapTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, bool iceP_azflag, bool iceP_rotflag, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MaximizeWrapTime_name);
    outAsync->invoke(iceC_lbto_IIFServer_MaximizeWrapTime_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_azflag, iceP_rotflag, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_PauseGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PauseGuiding_name);
    outAsync->invoke(iceC_lbto_IIFServer_PauseGuiding_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ResumeGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ResumeGuiding_name);
    outAsync->invoke(iceC_lbto_IIFServer_ResumeGuiding_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_StopGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StopGuiding_name);
    outAsync->invoke(iceC_lbto_IIFServer_StopGuiding_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetGuidingHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_coord1, double iceP_coord2, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetGuidingHotspot_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetGuidingHotspot_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_coord1, iceP_coord2, iceP_movetype, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetAGWFilter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, int iceP_filterNumber, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetAGWFilter_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetAGWFilter_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_filterNumber, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetGuidingBinning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, int iceP_factor, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetGuidingBinning_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetGuidingBinning_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_factor, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotReady(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, bool iceP_enable, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotReady_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotReady_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_enable, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotHold(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotHold_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotHold_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotTrack(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotTrack_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotTrack_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RotServicePosition(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_angle, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotServicePosition_name);
    outAsync->invoke(iceC_lbto_IIFServer_RotServicePosition_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_angle, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_PauseAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PauseAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_PauseAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ResumeAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ResumeAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_ResumeAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_StartAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StartAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_StartAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_StopAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_reason, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StopAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_StopAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_reason, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_AcquireRefAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, bool iceP_repointFlag, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_AcquireRefAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_AcquireRefAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_repointFlag, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_CheckRefAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_CheckRefAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_CheckRefAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RefineAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_method, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RefineAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_RefineAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_method, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_RunAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_type, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RunAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_RunAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_type, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_PresetFlatAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_flat, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetFlatAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_PresetFlatAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_flat, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_CorrectModesAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqModes& iceP_modes, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_CorrectModesAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_CorrectModesAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_modes, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ModifyAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, int iceP_NModes, double iceP_Freq, int iceP_Nbins, double iceP_TTMod, const ::std::string& iceP_F1spec, const ::std::string& iceP_F2spec, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ModifyAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_ModifyAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_NModes, iceP_Freq, iceP_Nbins, iceP_TTMod, iceP_F1spec, iceP_F2spec, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_PresetAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_AOMode, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_PresetAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_AOMode, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_OffsetXYAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_DeltaX, double iceP_DeltaY, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetXYAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_OffsetXYAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_DeltaX, iceP_DeltaY, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_OffsetZAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, double iceP_DeltaZ, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetZAO_name);
    outAsync->invoke(iceC_lbto_IIFServer_OffsetZAO_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_DeltaZ, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReference_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetReference_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetReferenceNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqNewPos& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReferenceNew_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetReferenceNew_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_SetReference2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos2& iceP_stars, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReference2_name);
    outAsync->invoke(iceC_lbto_IIFServer_SetReference2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_ClearReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearReference_name);
    outAsync->invoke(iceC_lbto_IIFServer_ClearReference_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetKFPCoordinates(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinates_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetKFPCoordinates_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetKFPCoordinatesNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqNewPos& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinatesNew_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetKFPCoordinatesNew_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_GetKFPCoordinates2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const SeqPos2& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinates2_name);
    outAsync->invoke(iceC_lbto_IIFServer_GetKFPCoordinates2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stars, iceP_side);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_NSQuery(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::iifres>>& outAsync, const ::std::string& iceP_targenName, const ::std::string& iceP_startDate, const ::std::string& iceP_startTime, const ::std::string& iceP_endDate, const ::std::string& iceP_endTime, const ::std::string& iceP_interval, const ::std::string& iceP_fileName, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_NSQuery_name);
    outAsync->invoke(iceC_lbto_IIFServer_NSQuery_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_targenName, iceP_startDate, iceP_startTime, iceP_endDate, iceP_endTime, iceP_interval, iceP_fileName);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
lbto::IIFServerPrx::_iceI_remove(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_lbto_IIFServer_remove_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
lbto::IIFServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<IIFServerPrx>();
}
/// \endcond

const ::std::string&
lbto::IIFServerPrx::ice_staticId()
{
    return IIFServer::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_lbto_IIFServer_ApplyWaffleAO_name = "ApplyWaffleAO";

const ::std::string iceC_lbto_IIFServer_Authorize_name = "Authorize";

const ::std::string iceC_lbto_IIFServer_StepFocus_name = "StepFocus";

const ::std::string iceC_lbto_IIFServer_MoveFocus_name = "MoveFocus";

const ::std::string iceC_lbto_IIFServer_OffsetPointing_name = "OffsetPointing";

const ::std::string iceC_lbto_IIFServer_OffsetPointing2_name = "OffsetPointing2";

const ::std::string iceC_lbto_IIFServer_OffsetGuiding_name = "OffsetGuiding";

const ::std::string iceC_lbto_IIFServer_UpdatePointingReference_name = "UpdatePointingReference";

const ::std::string iceC_lbto_IIFServer_TipTilt_name = "TipTilt";

const ::std::string iceC_lbto_IIFServer_SetPMTerm_name = "SetPMTerm";

const ::std::string iceC_lbto_IIFServer_SetPMTerm2_name = "SetPMTerm2";

const ::std::string iceC_lbto_IIFServer_MoveXYZ_name = "MoveXYZ";

const ::std::string iceC_lbto_IIFServer_MoveXY_name = "MoveXY";

const ::std::string iceC_lbto_IIFServer_Move_name = "Move";

const ::std::string iceC_lbto_IIFServer_SetTarget_name = "SetTarget";

const ::std::string iceC_lbto_IIFServer_SetStars_name = "SetStars";

const ::std::string iceC_lbto_IIFServer_SetStarsNew_name = "SetStarsNew";

const ::std::string iceC_lbto_IIFServer_SetStars2_name = "SetStars2";

const ::std::string iceC_lbto_IIFServer_ClearStars_name = "ClearStars";

const ::std::string iceC_lbto_IIFServer_SetHotspot_name = "SetHotspot";

const ::std::string iceC_lbto_IIFServer_ClearHotspot_name = "ClearHotspot";

const ::std::string iceC_lbto_IIFServer_SetOffset_name = "SetOffset";

const ::std::string iceC_lbto_IIFServer_SetOffsetNew_name = "SetOffsetNew";

const ::std::string iceC_lbto_IIFServer_SetOffset2_name = "SetOffset2";

const ::std::string iceC_lbto_IIFServer_ClearOffset_name = "ClearOffset";

const ::std::string iceC_lbto_IIFServer_SetNonSidereal_name = "SetNonSidereal";

const ::std::string iceC_lbto_IIFServer_ClearNonSidereal_name = "ClearNonSidereal";

const ::std::string iceC_lbto_IIFServer_UpdateNonSiderealTarget_name = "UpdateNonSiderealTarget";

const ::std::string iceC_lbto_IIFServer_SetNonSiderealObject_name = "SetNonSiderealObject";

const ::std::string iceC_lbto_IIFServer_ClearNonSiderealObject_name = "ClearNonSiderealObject";

const ::std::string iceC_lbto_IIFServer_UpdateNonSiderealObject_name = "UpdateNonSiderealObject";

const ::std::string iceC_lbto_IIFServer_PresetTelescope_name = "PresetTelescope";

const ::std::string iceC_lbto_IIFServer_BinocularControl_name = "BinocularControl";

const ::std::string iceC_lbto_IIFServer_GetParameter_name = "GetParameter";

const ::std::string iceC_lbto_IIFServer_SetParameter_name = "SetParameter";

const ::std::string iceC_lbto_IIFServer_RotateCommon_name = "RotateCommon";

const ::std::string iceC_lbto_IIFServer_RotateZ_name = "RotateZ";

const ::std::string iceC_lbto_IIFServer_RotatePrimary_name = "RotatePrimary";

const ::std::string iceC_lbto_IIFServer_SendWavefront_name = "SendWavefront";

const ::std::string iceC_lbto_IIFServer_UpdateTargetWavelength_name = "UpdateTargetWavelength";

const ::std::string iceC_lbto_IIFServer_LogEvent_name = "LogEvent";

const ::std::string iceC_lbto_IIFServer_GetRotatorTrajectory_name = "GetRotatorTrajectory";

const ::std::string iceC_lbto_IIFServer_GetRotatorPolynomials_name = "GetRotatorPolynomials";

const ::std::string iceC_lbto_IIFServer_Standby_name = "Standby";

const ::std::string iceC_lbto_IIFServer_MaximizeWrapTime_name = "MaximizeWrapTime";

const ::std::string iceC_lbto_IIFServer_PauseGuiding_name = "PauseGuiding";

const ::std::string iceC_lbto_IIFServer_ResumeGuiding_name = "ResumeGuiding";

const ::std::string iceC_lbto_IIFServer_StopGuiding_name = "StopGuiding";

const ::std::string iceC_lbto_IIFServer_SetGuidingHotspot_name = "SetGuidingHotspot";

const ::std::string iceC_lbto_IIFServer_SetAGWFilter_name = "SetAGWFilter";

const ::std::string iceC_lbto_IIFServer_SetGuidingBinning_name = "SetGuidingBinning";

const ::std::string iceC_lbto_IIFServer_RotReady_name = "RotReady";

const ::std::string iceC_lbto_IIFServer_RotHold_name = "RotHold";

const ::std::string iceC_lbto_IIFServer_RotTrack_name = "RotTrack";

const ::std::string iceC_lbto_IIFServer_RotServicePosition_name = "RotServicePosition";

const ::std::string iceC_lbto_IIFServer_PauseAO_name = "PauseAO";

const ::std::string iceC_lbto_IIFServer_ResumeAO_name = "ResumeAO";

const ::std::string iceC_lbto_IIFServer_StartAO_name = "StartAO";

const ::std::string iceC_lbto_IIFServer_StopAO_name = "StopAO";

const ::std::string iceC_lbto_IIFServer_AcquireRefAO_name = "AcquireRefAO";

const ::std::string iceC_lbto_IIFServer_CheckRefAO_name = "CheckRefAO";

const ::std::string iceC_lbto_IIFServer_RefineAO_name = "RefineAO";

const ::std::string iceC_lbto_IIFServer_RunAO_name = "RunAO";

const ::std::string iceC_lbto_IIFServer_PresetFlatAO_name = "PresetFlatAO";

const ::std::string iceC_lbto_IIFServer_CorrectModesAO_name = "CorrectModesAO";

const ::std::string iceC_lbto_IIFServer_ModifyAO_name = "ModifyAO";

const ::std::string iceC_lbto_IIFServer_PresetAO_name = "PresetAO";

const ::std::string iceC_lbto_IIFServer_OffsetXYAO_name = "OffsetXYAO";

const ::std::string iceC_lbto_IIFServer_OffsetZAO_name = "OffsetZAO";

const ::std::string iceC_lbto_IIFServer_SetReference_name = "SetReference";

const ::std::string iceC_lbto_IIFServer_SetReferenceNew_name = "SetReferenceNew";

const ::std::string iceC_lbto_IIFServer_SetReference2_name = "SetReference2";

const ::std::string iceC_lbto_IIFServer_ClearReference_name = "ClearReference";

const ::std::string iceC_lbto_IIFServer_GetKFPCoordinates_name = "GetKFPCoordinates";

const ::std::string iceC_lbto_IIFServer_GetKFPCoordinatesNew_name = "GetKFPCoordinatesNew";

const ::std::string iceC_lbto_IIFServer_GetKFPCoordinates2_name = "GetKFPCoordinates2";

const ::std::string iceC_lbto_IIFServer_NSQuery_name = "NSQuery";

const ::std::string iceC_lbto_IIFServer_remove_name = "remove";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::lbto::upCast(IIFServer* p) { return p; }

void
::IceProxy::lbto::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< IIFServer>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new IIFServer;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ApplyWaffleAO(const ::lbto::SeqModes& iceP_modes, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ApplyWaffleAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ApplyWaffleAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ApplyWaffleAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_modes);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ApplyWaffleAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ApplyWaffleAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ApplyWaffleAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_Authorize(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Authorize_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_Authorize_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_Authorize_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_Authorize_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_Authorize(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_Authorize_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_StepFocus(::Ice::Double iceP_relPos, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StepFocus_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_StepFocus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_StepFocus_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_relPos);
        ostr->write(iceP_ope);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_StepFocus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_StepFocus(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_StepFocus_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_MoveFocus(::Ice::Double iceP_absPos, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveFocus_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_MoveFocus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_MoveFocus_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_absPos);
        ostr->write(iceP_ope);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_MoveFocus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_MoveFocus(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_MoveFocus_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_OffsetPointing(::Ice::Double iceP_rotangle, ::Ice::Double iceP_offx, ::Ice::Double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_ope, const ::std::string& iceP_np, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetPointing_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_OffsetPointing_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_OffsetPointing_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_rotangle);
        ostr->write(iceP_offx);
        ostr->write(iceP_offy);
        ostr->write(iceP_coordsys);
        ostr->write(iceP_ope);
        ostr->write(iceP_np);
        ostr->write(iceP_movetype);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_OffsetPointing_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_OffsetPointing(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_OffsetPointing_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_OffsetPointing2(::Ice::Double iceP_rotangle, ::Ice::Double iceP_offx, ::Ice::Double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetPointing2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_OffsetPointing2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_OffsetPointing2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_rotangle);
        ostr->write(iceP_offx);
        ostr->write(iceP_offy);
        ostr->write(iceP_coordsys);
        ostr->write(iceP_movetype);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_OffsetPointing2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_OffsetPointing2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_OffsetPointing2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_OffsetGuiding(::Ice::Double iceP_rotangle, ::Ice::Double iceP_offx, ::Ice::Double iceP_offy, const ::std::string& iceP_coordsys, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetGuiding_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_OffsetGuiding_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_OffsetGuiding_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_rotangle);
        ostr->write(iceP_offx);
        ostr->write(iceP_offy);
        ostr->write(iceP_coordsys);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_OffsetGuiding_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_OffsetGuiding(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_OffsetGuiding_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_UpdatePointingReference(const ::std::string& iceP_offsetcoord, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdatePointingReference_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_UpdatePointingReference_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_UpdatePointingReference_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_offsetcoord);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_UpdatePointingReference_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_UpdatePointingReference(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_UpdatePointingReference_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_TipTilt(::Ice::Double iceP_xrot, ::Ice::Double iceP_yrot, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_TipTilt_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_TipTilt_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_TipTilt_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_xrot);
        ostr->write(iceP_yrot);
        ostr->write(iceP_ope);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_TipTilt_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_TipTilt(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_TipTilt_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetPMTerm(const ::std::string& iceP_name, ::Ice::Double iceP_value, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetPMTerm_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetPMTerm_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetPMTerm_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_value);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetPMTerm_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetPMTerm(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetPMTerm_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetPMTerm2(const ::std::string& iceP_name, ::Ice::Double iceP_value, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetPMTerm2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetPMTerm2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetPMTerm2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_value);
        ostr->write(iceP_movetype);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetPMTerm2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetPMTerm2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetPMTerm2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_MoveXYZ(::Ice::Double iceP_xmov, ::Ice::Double iceP_ymov, ::Ice::Double iceP_zmov, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveXYZ_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_MoveXYZ_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_MoveXYZ_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_xmov);
        ostr->write(iceP_ymov);
        ostr->write(iceP_zmov);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_MoveXYZ_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_MoveXYZ(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_MoveXYZ_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_MoveXY(::Ice::Double iceP_xmov, ::Ice::Double iceP_ymov, const ::std::string& iceP_ope, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MoveXY_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_MoveXY_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_MoveXY_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_xmov);
        ostr->write(iceP_ymov);
        ostr->write(iceP_ope);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_MoveXY_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_MoveXY(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_MoveXY_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_Move(::Ice::Double iceP_x, ::Ice::Double iceP_y, ::Ice::Double iceP_z, ::Ice::Double iceP_rx, ::Ice::Double iceP_ry, ::Ice::Double iceP_rz, ::Ice::Int iceP_dflag, const ::std::string& iceP_movetype, const ::std::string& iceP_OPE, ::Ice::Int iceP_time, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Move_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_Move_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_Move_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_x);
        ostr->write(iceP_y);
        ostr->write(iceP_z);
        ostr->write(iceP_rx);
        ostr->write(iceP_ry);
        ostr->write(iceP_rz);
        ostr->write(iceP_dflag);
        ostr->write(iceP_movetype);
        ostr->write(iceP_OPE);
        ostr->write(iceP_time);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_Move_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_Move(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_Move_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetTarget(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::std::string& iceP_system, ::Ice::Double iceP_epoch, ::Ice::Float iceP_wavelength, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetTarget_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetTarget_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetTarget_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        ostr->write(iceP_system);
        ostr->write(iceP_epoch);
        ostr->write(iceP_wavelength);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetTarget_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetTarget(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetTarget_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetStars(const ::lbto::SeqPos& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStars_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetStars_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetStars_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetStars_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetStars(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetStars_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetStarsNew(const ::lbto::SeqNewPos& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStarsNew_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetStarsNew_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetStarsNew_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetStarsNew_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetStarsNew(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetStarsNew_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetStars2(const ::lbto::SeqPos2& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetStars2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetStars2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetStars2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetStars2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetStars2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetStars2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearStars(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearStars_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearStars_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearStars_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_ClearStars_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearStars(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearStars_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetHotspot(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetHotspot_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetHotspot_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetHotspot_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetHotspot_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetHotspot(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetHotspot_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearHotspot(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearHotspot_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearHotspot_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearHotspot_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_ClearHotspot_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearHotspot(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearHotspot_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetOffset(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::std::string& iceP_system, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffset_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetOffset_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetOffset_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        ostr->write(iceP_system);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetOffset_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetOffset(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetOffset_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetOffsetNew(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::std::string& iceP_system, const ::std::string& iceP_movetype, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffsetNew_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetOffsetNew_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetOffsetNew_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        ostr->write(iceP_system);
        ostr->write(iceP_movetype);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetOffsetNew_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetOffsetNew(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetOffsetNew_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetOffset2(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::std::string& iceP_system, const ::std::string& iceP_movetype, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetOffset2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetOffset2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetOffset2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        ostr->write(iceP_system);
        ostr->write(iceP_movetype);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetOffset2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetOffset2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetOffset2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearOffset(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearOffset_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearOffset_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearOffset_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_ClearOffset_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearOffset(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearOffset_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetNonSidereal(const ::lbto::nonsidereal& iceP_target, bool iceP_override, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetNonSidereal_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetNonSidereal_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetNonSidereal_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_target);
        ostr->write(iceP_override);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetNonSidereal_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetNonSidereal(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetNonSidereal_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearNonSidereal(bool iceP_override, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearNonSidereal_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearNonSidereal_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearNonSidereal_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_override);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ClearNonSidereal_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearNonSidereal(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearNonSidereal_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_UpdateNonSiderealTarget(::Ice::Double iceP_RArate, ::Ice::Double iceP_DECrate, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateNonSiderealTarget_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_UpdateNonSiderealTarget_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_UpdateNonSiderealTarget_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_RArate);
        ostr->write(iceP_DECrate);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_UpdateNonSiderealTarget_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_UpdateNonSiderealTarget(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_UpdateNonSiderealTarget_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetNonSiderealObject(const ::std::string& iceP_objtype, const ::lbto::nonsidereal& iceP_target, bool iceP_override, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetNonSiderealObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetNonSiderealObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetNonSiderealObject_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_objtype);
        ostr->write(iceP_target);
        ostr->write(iceP_override);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetNonSiderealObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetNonSiderealObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetNonSiderealObject_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearNonSiderealObject(const ::std::string& iceP_objtype, bool iceP_override, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearNonSiderealObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearNonSiderealObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearNonSiderealObject_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_objtype);
        ostr->write(iceP_override);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ClearNonSiderealObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearNonSiderealObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearNonSiderealObject_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_UpdateNonSiderealObject(const ::std::string& iceP_objtype, ::Ice::Double iceP_RArate, ::Ice::Double iceP_DECrate, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateNonSiderealObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_UpdateNonSiderealObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_UpdateNonSiderealObject_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_objtype);
        ostr->write(iceP_RArate);
        ostr->write(iceP_DECrate);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_UpdateNonSiderealObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_UpdateNonSiderealObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_UpdateNonSiderealObject_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_PresetTelescope(::Ice::Double iceP_rotangle, const ::std::string& iceP_rotmode, const ::std::string& iceP_mode, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetTelescope_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_PresetTelescope_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_PresetTelescope_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_rotangle);
        ostr->write(iceP_rotmode);
        ostr->write(iceP_mode);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_PresetTelescope_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_PresetTelescope(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_PresetTelescope_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_BinocularControl(const ::std::string& iceP_flag, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_BinocularControl_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_BinocularControl_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_BinocularControl_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_flag);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_BinocularControl_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_BinocularControl(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_BinocularControl_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetParameter(const ::lbto::SeqDD& iceP_list, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetParameter_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetParameter_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetParameter_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_list);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetParameter_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetParameter(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetParameter_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetParameter(const ::lbto::SeqDD& iceP_list, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetParameter_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetParameter_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetParameter_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_list);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetParameter_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetParameter(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetParameter_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotateCommon(::Ice::Double iceP_z, ::Ice::Double iceP_angle, ::Ice::Double iceP_direction, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotateCommon_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotateCommon_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotateCommon_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_z);
        ostr->write(iceP_angle);
        ostr->write(iceP_direction);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotateCommon_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotateCommon(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotateCommon_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotateZ(::Ice::Double iceP_angle, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotateZ_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotateZ_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotateZ_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_angle);
        ostr->write(iceP_movetype);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotateZ_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotateZ(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotateZ_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotatePrimary(::Ice::Double iceP_distance, ::Ice::Double iceP_angle, ::Ice::Double iceP_direction, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotatePrimary_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotatePrimary_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotatePrimary_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_distance);
        ostr->write(iceP_angle);
        ostr->write(iceP_direction);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotatePrimary_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotatePrimary(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotatePrimary_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SendWavefront(const ::lbto::SeqWF& iceP_wfs, const ::std::string& iceP_OPE, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SendWavefront_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SendWavefront_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SendWavefront_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_wfs);
        ostr->write(iceP_OPE);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SendWavefront_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SendWavefront(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SendWavefront_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_UpdateTargetWavelength(::Ice::Float iceP_wavelength, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_UpdateTargetWavelength_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_UpdateTargetWavelength_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_UpdateTargetWavelength_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_wavelength);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_UpdateTargetWavelength_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_UpdateTargetWavelength(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_UpdateTargetWavelength_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_LogEvent(const ::std::string& iceP_event, const ::std::string& iceP_description, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_LogEvent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_LogEvent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_LogEvent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_event);
        ostr->write(iceP_description);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_LogEvent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_LogEvent(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_LogEvent_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetRotatorTrajectory(::Ice::Double iceP_seconds, ::Ice::Double iceP_interval, ::Ice::Double iceP_start, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetRotatorTrajectory_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetRotatorTrajectory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetRotatorTrajectory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_seconds);
        ostr->write(iceP_interval);
        ostr->write(iceP_start);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetRotatorTrajectory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetRotatorTrajectory(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetRotatorTrajectory_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetRotatorPolynomials(::Ice::Double iceP_start, ::Ice::Int iceP_count, ::Ice::Double iceP_interval, ::Ice::Int iceP_order, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetRotatorPolynomials_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetRotatorPolynomials_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetRotatorPolynomials_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_start);
        ostr->write(iceP_count);
        ostr->write(iceP_interval);
        ostr->write(iceP_order);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetRotatorPolynomials_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetRotatorPolynomials(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetRotatorPolynomials_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_Standby(::Ice::Int iceP_level, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_Standby_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_Standby_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_Standby_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_level);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_Standby_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_Standby(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_Standby_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_MaximizeWrapTime(bool iceP_azflag, bool iceP_rotflag, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_MaximizeWrapTime_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_MaximizeWrapTime_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_MaximizeWrapTime_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_azflag);
        ostr->write(iceP_rotflag);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_MaximizeWrapTime_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_MaximizeWrapTime(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_MaximizeWrapTime_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_PauseGuiding(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PauseGuiding_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_PauseGuiding_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_PauseGuiding_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_PauseGuiding_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_PauseGuiding(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_PauseGuiding_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ResumeGuiding(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ResumeGuiding_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ResumeGuiding_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ResumeGuiding_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ResumeGuiding_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ResumeGuiding(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ResumeGuiding_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_StopGuiding(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StopGuiding_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_StopGuiding_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_StopGuiding_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_StopGuiding_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_StopGuiding(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_StopGuiding_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetGuidingHotspot(::Ice::Double iceP_coord1, ::Ice::Double iceP_coord2, const ::std::string& iceP_movetype, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetGuidingHotspot_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetGuidingHotspot_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetGuidingHotspot_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_coord1);
        ostr->write(iceP_coord2);
        ostr->write(iceP_movetype);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetGuidingHotspot_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetGuidingHotspot(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetGuidingHotspot_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetAGWFilter(::Ice::Int iceP_filterNumber, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetAGWFilter_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetAGWFilter_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetAGWFilter_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_filterNumber);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetAGWFilter_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetAGWFilter(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetAGWFilter_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetGuidingBinning(::Ice::Int iceP_factor, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetGuidingBinning_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetGuidingBinning_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetGuidingBinning_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_factor);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetGuidingBinning_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetGuidingBinning(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetGuidingBinning_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotReady(bool iceP_enable, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotReady_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotReady_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotReady_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_enable);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotReady_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotReady(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotReady_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotHold(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotHold_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotHold_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotHold_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotHold_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotHold(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotHold_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotTrack(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotTrack_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotTrack_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotTrack_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotTrack_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotTrack(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotTrack_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RotServicePosition(::Ice::Double iceP_angle, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RotServicePosition_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RotServicePosition_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RotServicePosition_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_angle);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RotServicePosition_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RotServicePosition(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RotServicePosition_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_PauseAO(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PauseAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_PauseAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_PauseAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_PauseAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_PauseAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_PauseAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ResumeAO(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ResumeAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ResumeAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ResumeAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ResumeAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ResumeAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ResumeAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_StartAO(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StartAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_StartAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_StartAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_StartAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_StartAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_StartAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_StopAO(const ::std::string& iceP_reason, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_StopAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_StopAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_StopAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_reason);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_StopAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_StopAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_StopAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_AcquireRefAO(bool iceP_repointFlag, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_AcquireRefAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_AcquireRefAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_AcquireRefAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_repointFlag);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_AcquireRefAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_AcquireRefAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_AcquireRefAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_CheckRefAO(const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_CheckRefAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_CheckRefAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_CheckRefAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_CheckRefAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_CheckRefAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_CheckRefAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RefineAO(const ::std::string& iceP_method, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RefineAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RefineAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RefineAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_method);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RefineAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RefineAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RefineAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_RunAO(const ::std::string& iceP_type, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_RunAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_RunAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_RunAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_type);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_RunAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_RunAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_RunAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_PresetFlatAO(const ::std::string& iceP_flat, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetFlatAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_PresetFlatAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_PresetFlatAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_flat);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_PresetFlatAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_PresetFlatAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_PresetFlatAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_CorrectModesAO(const ::lbto::SeqModes& iceP_modes, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_CorrectModesAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_CorrectModesAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_CorrectModesAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_modes);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_CorrectModesAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_CorrectModesAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_CorrectModesAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ModifyAO(::Ice::Int iceP_NModes, ::Ice::Double iceP_Freq, ::Ice::Int iceP_Nbins, ::Ice::Double iceP_TTMod, const ::std::string& iceP_F1spec, const ::std::string& iceP_F2spec, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ModifyAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ModifyAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ModifyAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_NModes);
        ostr->write(iceP_Freq);
        ostr->write(iceP_Nbins);
        ostr->write(iceP_TTMod);
        ostr->write(iceP_F1spec);
        ostr->write(iceP_F2spec);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_ModifyAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ModifyAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ModifyAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_PresetAO(const ::std::string& iceP_AOMode, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_PresetAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_PresetAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_PresetAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_AOMode);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_PresetAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_PresetAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_PresetAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_OffsetXYAO(::Ice::Double iceP_DeltaX, ::Ice::Double iceP_DeltaY, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetXYAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_OffsetXYAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_OffsetXYAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_DeltaX);
        ostr->write(iceP_DeltaY);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_OffsetXYAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_OffsetXYAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_OffsetXYAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_OffsetZAO(::Ice::Double iceP_DeltaZ, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_OffsetZAO_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_OffsetZAO_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_OffsetZAO_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_DeltaZ);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_OffsetZAO_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_OffsetZAO(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_OffsetZAO_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetReference(const ::lbto::SeqPos& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReference_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetReference_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetReference_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetReference_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetReference(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetReference_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetReferenceNew(const ::lbto::SeqNewPos& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReferenceNew_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetReferenceNew_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetReferenceNew_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetReferenceNew_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetReferenceNew(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetReferenceNew_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_SetReference2(const ::lbto::SeqPos2& iceP_stars, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_SetReference2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_SetReference2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_SetReference2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_SetReference2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_SetReference2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_SetReference2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_ClearReference(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_ClearReference_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_ClearReference_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_ClearReference_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_ClearReference_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_ClearReference(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_ClearReference_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetKFPCoordinates(const ::lbto::SeqPos& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinates_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetKFPCoordinates_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetKFPCoordinates_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetKFPCoordinates_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetKFPCoordinates(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetKFPCoordinates_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinatesNew_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetKFPCoordinatesNew_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetKFPCoordinatesNew_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetKFPCoordinatesNew_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetKFPCoordinatesNew(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetKFPCoordinatesNew_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_GetKFPCoordinates2(const ::lbto::SeqPos2& iceP_stars, const ::std::string& iceP_side, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_GetKFPCoordinates2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_GetKFPCoordinates2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_GetKFPCoordinates2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stars);
        ostr->write(iceP_side);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_GetKFPCoordinates2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_GetKFPCoordinates2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_GetKFPCoordinates2_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_NSQuery(const ::std::string& iceP_targenName, const ::std::string& iceP_startDate, const ::std::string& iceP_startTime, const ::std::string& iceP_endDate, const ::std::string& iceP_endTime, const ::std::string& iceP_interval, const ::std::string& iceP_fileName, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_lbto_IIFServer_NSQuery_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_NSQuery_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_NSQuery_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_targenName);
        ostr->write(iceP_startDate);
        ostr->write(iceP_startTime);
        ostr->write(iceP_endDate);
        ostr->write(iceP_endTime);
        ostr->write(iceP_interval);
        ostr->write(iceP_fileName);
        result->endWriteParams();
        result->invoke(iceC_lbto_IIFServer_NSQuery_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::lbto::iifres
IceProxy::lbto::IIFServer::end_NSQuery(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_lbto_IIFServer_NSQuery_name);
    ::lbto::iifres ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::lbto::IIFServer::_iceI_begin_remove(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_lbto_IIFServer_remove_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_lbto_IIFServer_remove_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_lbto_IIFServer_remove_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::lbto::IIFServer::end_remove(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_lbto_IIFServer_remove_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::lbto::IIFServer::_newInstance() const
{
    return new IIFServer;
}
/// \endcond

const ::std::string&
IceProxy::lbto::IIFServer::ice_staticId()
{
    return ::lbto::IIFServer::ice_staticId();
}

lbto::IIFServer::~IIFServer()
{
}

/// \cond INTERNAL
::Ice::Object* lbto::upCast(IIFServer* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_lbto_IIFServer_ids[2] =
{
    "::Ice::Object",
    "::lbto::IIFServer"
};

}

bool
lbto::IIFServer::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_lbto_IIFServer_ids, iceC_lbto_IIFServer_ids + 2, s);
}

::std::vector< ::std::string>
lbto::IIFServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_lbto_IIFServer_ids[0], &iceC_lbto_IIFServer_ids[2]);
}

const ::std::string&
lbto::IIFServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
lbto::IIFServer::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::lbto::IIFServer";
    return typeId;
#else
    return iceC_lbto_IIFServer_ids[1];
#endif
}

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ApplyWaffleAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqModes iceP_modes;
    ::std::string iceP_side;
    istr->read(iceP_modes);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->ApplyWaffleAO(iceP_modes, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Authorize(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->Authorize(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StepFocus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_relPos;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->read(iceP_relPos);
    istr->read(iceP_ope);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->StepFocus(iceP_relPos, iceP_ope, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveFocus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_absPos;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->read(iceP_absPos);
    istr->read(iceP_ope);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveFocus(iceP_absPos, iceP_ope, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetPointing(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_rotangle;
    ::Ice::Double iceP_offx;
    ::Ice::Double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_ope;
    ::std::string iceP_np;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->read(iceP_rotangle);
    istr->read(iceP_offx);
    istr->read(iceP_offy);
    istr->read(iceP_coordsys);
    istr->read(iceP_ope);
    istr->read(iceP_np);
    istr->read(iceP_movetype);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetPointing(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_ope, iceP_np, iceP_movetype, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetPointing2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_rotangle;
    ::Ice::Double iceP_offx;
    ::Ice::Double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->read(iceP_rotangle);
    istr->read(iceP_offx);
    istr->read(iceP_offy);
    istr->read(iceP_coordsys);
    istr->read(iceP_movetype);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetPointing2(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_movetype, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_rotangle;
    ::Ice::Double iceP_offx;
    ::Ice::Double iceP_offy;
    ::std::string iceP_coordsys;
    ::std::string iceP_side;
    istr->read(iceP_rotangle);
    istr->read(iceP_offx);
    istr->read(iceP_offy);
    istr->read(iceP_coordsys);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetGuiding(iceP_rotangle, iceP_offx, iceP_offy, iceP_coordsys, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdatePointingReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_offsetcoord;
    ::std::string iceP_side;
    istr->read(iceP_offsetcoord);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->UpdatePointingReference(iceP_offsetcoord, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_TipTilt(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_xrot;
    ::Ice::Double iceP_yrot;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->read(iceP_xrot);
    istr->read(iceP_yrot);
    istr->read(iceP_ope);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->TipTilt(iceP_xrot, iceP_yrot, iceP_ope, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetPMTerm(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Double iceP_value;
    ::std::string iceP_side;
    istr->read(iceP_name);
    istr->read(iceP_value);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SetPMTerm(iceP_name, iceP_value, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetPMTerm2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Double iceP_value;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->read(iceP_name);
    istr->read(iceP_value);
    istr->read(iceP_movetype);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SetPMTerm2(iceP_name, iceP_value, iceP_movetype, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveXYZ(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_xmov;
    ::Ice::Double iceP_ymov;
    ::Ice::Double iceP_zmov;
    ::std::string iceP_side;
    istr->read(iceP_xmov);
    istr->read(iceP_ymov);
    istr->read(iceP_zmov);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveXYZ(iceP_xmov, iceP_ymov, iceP_zmov, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MoveXY(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_xmov;
    ::Ice::Double iceP_ymov;
    ::std::string iceP_ope;
    ::std::string iceP_side;
    istr->read(iceP_xmov);
    istr->read(iceP_ymov);
    istr->read(iceP_ope);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->MoveXY(iceP_xmov, iceP_ymov, iceP_ope, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Move(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_x;
    ::Ice::Double iceP_y;
    ::Ice::Double iceP_z;
    ::Ice::Double iceP_rx;
    ::Ice::Double iceP_ry;
    ::Ice::Double iceP_rz;
    ::Ice::Int iceP_dflag;
    ::std::string iceP_movetype;
    ::std::string iceP_OPE;
    ::Ice::Int iceP_time;
    ::std::string iceP_side;
    istr->read(iceP_x);
    istr->read(iceP_y);
    istr->read(iceP_z);
    istr->read(iceP_rx);
    istr->read(iceP_ry);
    istr->read(iceP_rz);
    istr->read(iceP_dflag);
    istr->read(iceP_movetype);
    istr->read(iceP_OPE);
    istr->read(iceP_time);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->Move(iceP_x, iceP_y, iceP_z, iceP_rx, iceP_ry, iceP_rz, iceP_dflag, iceP_movetype, iceP_OPE, iceP_time, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetTarget(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    ::std::string iceP_system;
    ::Ice::Double iceP_epoch;
    ::Ice::Float iceP_wavelength;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    istr->read(iceP_system);
    istr->read(iceP_epoch);
    istr->read(iceP_wavelength);
    inS.endReadParams();
    iifres ret = this->SetTarget(iceP_coord1, iceP_coord2, iceP_system, iceP_epoch, iceP_wavelength, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStars(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStars(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStarsNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStarsNew(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetStars2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetStars2(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearStars(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearStars(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    inS.endReadParams();
    iifres ret = this->SetHotspot(iceP_coord1, iceP_coord2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearHotspot(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    ::std::string iceP_system;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    istr->read(iceP_system);
    inS.endReadParams();
    iifres ret = this->SetOffset(iceP_coord1, iceP_coord2, iceP_system, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffsetNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    ::std::string iceP_system;
    ::std::string iceP_movetype;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    istr->read(iceP_system);
    istr->read(iceP_movetype);
    inS.endReadParams();
    iifres ret = this->SetOffsetNew(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetOffset2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    ::std::string iceP_system;
    ::std::string iceP_movetype;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    istr->read(iceP_system);
    istr->read(iceP_movetype);
    inS.endReadParams();
    iifres ret = this->SetOffset2(iceP_coord1, iceP_coord2, iceP_system, iceP_movetype, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearOffset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearOffset(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetNonSidereal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    nonsidereal iceP_target;
    bool iceP_override;
    istr->read(iceP_target);
    istr->read(iceP_override);
    inS.endReadParams();
    iifres ret = this->SetNonSidereal(iceP_target, iceP_override, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearNonSidereal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_override;
    istr->read(iceP_override);
    inS.endReadParams();
    iifres ret = this->ClearNonSidereal(iceP_override, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateNonSiderealTarget(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_RArate;
    ::Ice::Double iceP_DECrate;
    istr->read(iceP_RArate);
    istr->read(iceP_DECrate);
    inS.endReadParams();
    iifres ret = this->UpdateNonSiderealTarget(iceP_RArate, iceP_DECrate, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_objtype;
    nonsidereal iceP_target;
    bool iceP_override;
    istr->read(iceP_objtype);
    istr->read(iceP_target);
    istr->read(iceP_override);
    inS.endReadParams();
    iifres ret = this->SetNonSiderealObject(iceP_objtype, iceP_target, iceP_override, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_objtype;
    bool iceP_override;
    istr->read(iceP_objtype);
    istr->read(iceP_override);
    inS.endReadParams();
    iifres ret = this->ClearNonSiderealObject(iceP_objtype, iceP_override, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateNonSiderealObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_objtype;
    ::Ice::Double iceP_RArate;
    ::Ice::Double iceP_DECrate;
    istr->read(iceP_objtype);
    istr->read(iceP_RArate);
    istr->read(iceP_DECrate);
    inS.endReadParams();
    iifres ret = this->UpdateNonSiderealObject(iceP_objtype, iceP_RArate, iceP_DECrate, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetTelescope(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_rotangle;
    ::std::string iceP_rotmode;
    ::std::string iceP_mode;
    ::std::string iceP_side;
    istr->read(iceP_rotangle);
    istr->read(iceP_rotmode);
    istr->read(iceP_mode);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetTelescope(iceP_rotangle, iceP_rotmode, iceP_mode, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_BinocularControl(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_flag;
    istr->read(iceP_flag);
    inS.endReadParams();
    iifres ret = this->BinocularControl(iceP_flag, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetParameter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqDD iceP_list;
    istr->read(iceP_list);
    inS.endReadParams();
    iifres ret = this->GetParameter(iceP_list, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetParameter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqDD iceP_list;
    istr->read(iceP_list);
    inS.endReadParams();
    iifres ret = this->SetParameter(iceP_list, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotateCommon(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_z;
    ::Ice::Double iceP_angle;
    ::Ice::Double iceP_direction;
    ::std::string iceP_side;
    istr->read(iceP_z);
    istr->read(iceP_angle);
    istr->read(iceP_direction);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotateCommon(iceP_z, iceP_angle, iceP_direction, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotateZ(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_angle;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->read(iceP_angle);
    istr->read(iceP_movetype);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotateZ(iceP_angle, iceP_movetype, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotatePrimary(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_distance;
    ::Ice::Double iceP_angle;
    ::Ice::Double iceP_direction;
    ::std::string iceP_side;
    istr->read(iceP_distance);
    istr->read(iceP_angle);
    istr->read(iceP_direction);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotatePrimary(iceP_distance, iceP_angle, iceP_direction, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SendWavefront(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqWF iceP_wfs;
    ::std::string iceP_OPE;
    ::std::string iceP_side;
    istr->read(iceP_wfs);
    istr->read(iceP_OPE);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SendWavefront(iceP_wfs, iceP_OPE, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_UpdateTargetWavelength(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Float iceP_wavelength;
    ::std::string iceP_side;
    istr->read(iceP_wavelength);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->UpdateTargetWavelength(iceP_wavelength, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_LogEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_event;
    ::std::string iceP_description;
    istr->read(iceP_event);
    istr->read(iceP_description);
    inS.endReadParams();
    iifres ret = this->LogEvent(iceP_event, iceP_description, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetRotatorTrajectory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_seconds;
    ::Ice::Double iceP_interval;
    ::Ice::Double iceP_start;
    ::std::string iceP_side;
    istr->read(iceP_seconds);
    istr->read(iceP_interval);
    istr->read(iceP_start);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->GetRotatorTrajectory(iceP_seconds, iceP_interval, iceP_start, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetRotatorPolynomials(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_start;
    ::Ice::Int iceP_count;
    ::Ice::Double iceP_interval;
    ::Ice::Int iceP_order;
    ::std::string iceP_side;
    istr->read(iceP_start);
    istr->read(iceP_count);
    istr->read(iceP_interval);
    istr->read(iceP_order);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->GetRotatorPolynomials(iceP_start, iceP_count, iceP_interval, iceP_order, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_Standby(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_level;
    ::std::string iceP_side;
    istr->read(iceP_level);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->Standby(iceP_level, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_MaximizeWrapTime(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_azflag;
    bool iceP_rotflag;
    ::std::string iceP_side;
    istr->read(iceP_azflag);
    istr->read(iceP_rotflag);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->MaximizeWrapTime(iceP_azflag, iceP_rotflag, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PauseGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->PauseGuiding(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ResumeGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->ResumeGuiding(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StopGuiding(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->StopGuiding(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetGuidingHotspot(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_coord1;
    ::Ice::Double iceP_coord2;
    ::std::string iceP_movetype;
    ::std::string iceP_side;
    istr->read(iceP_coord1);
    istr->read(iceP_coord2);
    istr->read(iceP_movetype);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SetGuidingHotspot(iceP_coord1, iceP_coord2, iceP_movetype, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetAGWFilter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_filterNumber;
    ::std::string iceP_side;
    istr->read(iceP_filterNumber);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SetAGWFilter(iceP_filterNumber, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetGuidingBinning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_factor;
    ::std::string iceP_side;
    istr->read(iceP_factor);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->SetGuidingBinning(iceP_factor, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotReady(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_enable;
    ::std::string iceP_side;
    istr->read(iceP_enable);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotReady(iceP_enable, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotHold(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotHold(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotTrack(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotTrack(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RotServicePosition(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_angle;
    ::std::string iceP_side;
    istr->read(iceP_angle);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RotServicePosition(iceP_angle, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PauseAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->PauseAO(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ResumeAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->ResumeAO(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StartAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->StartAO(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_StopAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_reason;
    ::std::string iceP_side;
    istr->read(iceP_reason);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->StopAO(iceP_reason, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_AcquireRefAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_repointFlag;
    ::std::string iceP_side;
    istr->read(iceP_repointFlag);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->AcquireRefAO(iceP_repointFlag, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_CheckRefAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_side;
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->CheckRefAO(iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RefineAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_method;
    ::std::string iceP_side;
    istr->read(iceP_method);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RefineAO(iceP_method, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_RunAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_type;
    ::std::string iceP_side;
    istr->read(iceP_type);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->RunAO(iceP_type, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetFlatAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_flat;
    ::std::string iceP_side;
    istr->read(iceP_flat);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetFlatAO(iceP_flat, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_CorrectModesAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqModes iceP_modes;
    ::std::string iceP_side;
    istr->read(iceP_modes);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->CorrectModesAO(iceP_modes, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ModifyAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_NModes;
    ::Ice::Double iceP_Freq;
    ::Ice::Int iceP_Nbins;
    ::Ice::Double iceP_TTMod;
    ::std::string iceP_F1spec;
    ::std::string iceP_F2spec;
    ::std::string iceP_side;
    istr->read(iceP_NModes);
    istr->read(iceP_Freq);
    istr->read(iceP_Nbins);
    istr->read(iceP_TTMod);
    istr->read(iceP_F1spec);
    istr->read(iceP_F2spec);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->ModifyAO(iceP_NModes, iceP_Freq, iceP_Nbins, iceP_TTMod, iceP_F1spec, iceP_F2spec, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_PresetAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_AOMode;
    ::std::string iceP_side;
    istr->read(iceP_AOMode);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->PresetAO(iceP_AOMode, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetXYAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_DeltaX;
    ::Ice::Double iceP_DeltaY;
    ::std::string iceP_side;
    istr->read(iceP_DeltaX);
    istr->read(iceP_DeltaY);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetXYAO(iceP_DeltaX, iceP_DeltaY, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_OffsetZAO(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_DeltaZ;
    ::std::string iceP_side;
    istr->read(iceP_DeltaZ);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->OffsetZAO(iceP_DeltaZ, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReference(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReferenceNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReferenceNew(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_SetReference2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    istr->read(iceP_stars);
    inS.endReadParams();
    iifres ret = this->SetReference2(iceP_stars, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_ClearReference(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    iifres ret = this->ClearReference(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinates(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos iceP_stars;
    ::std::string iceP_side;
    istr->read(iceP_stars);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinates(iceP_stars, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinatesNew(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqNewPos iceP_stars;
    ::std::string iceP_side;
    istr->read(iceP_stars);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinatesNew(iceP_stars, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_GetKFPCoordinates2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SeqPos2 iceP_stars;
    ::std::string iceP_side;
    istr->read(iceP_stars);
    istr->read(iceP_side);
    inS.endReadParams();
    iifres ret = this->GetKFPCoordinates2(iceP_stars, iceP_side, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_NSQuery(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_targenName;
    ::std::string iceP_startDate;
    ::std::string iceP_startTime;
    ::std::string iceP_endDate;
    ::std::string iceP_endTime;
    ::std::string iceP_interval;
    ::std::string iceP_fileName;
    istr->read(iceP_targenName);
    istr->read(iceP_startDate);
    istr->read(iceP_startTime);
    istr->read(iceP_endDate);
    istr->read(iceP_endTime);
    istr->read(iceP_interval);
    istr->read(iceP_fileName);
    inS.endReadParams();
    iifres ret = this->NSQuery(iceP_targenName, iceP_startDate, iceP_startTime, iceP_endDate, iceP_endTime, iceP_interval, iceP_fileName, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
lbto::IIFServer::_iceD_remove(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->remove(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_lbto_IIFServer_all[] =
{
    "AcquireRefAO",
    "ApplyWaffleAO",
    "Authorize",
    "BinocularControl",
    "CheckRefAO",
    "ClearHotspot",
    "ClearNonSidereal",
    "ClearNonSiderealObject",
    "ClearOffset",
    "ClearReference",
    "ClearStars",
    "CorrectModesAO",
    "GetKFPCoordinates",
    "GetKFPCoordinates2",
    "GetKFPCoordinatesNew",
    "GetParameter",
    "GetRotatorPolynomials",
    "GetRotatorTrajectory",
    "LogEvent",
    "MaximizeWrapTime",
    "ModifyAO",
    "Move",
    "MoveFocus",
    "MoveXY",
    "MoveXYZ",
    "NSQuery",
    "OffsetGuiding",
    "OffsetPointing",
    "OffsetPointing2",
    "OffsetXYAO",
    "OffsetZAO",
    "PauseAO",
    "PauseGuiding",
    "PresetAO",
    "PresetFlatAO",
    "PresetTelescope",
    "RefineAO",
    "ResumeAO",
    "ResumeGuiding",
    "RotHold",
    "RotReady",
    "RotServicePosition",
    "RotTrack",
    "RotateCommon",
    "RotatePrimary",
    "RotateZ",
    "RunAO",
    "SendWavefront",
    "SetAGWFilter",
    "SetGuidingBinning",
    "SetGuidingHotspot",
    "SetHotspot",
    "SetNonSidereal",
    "SetNonSiderealObject",
    "SetOffset",
    "SetOffset2",
    "SetOffsetNew",
    "SetPMTerm",
    "SetPMTerm2",
    "SetParameter",
    "SetReference",
    "SetReference2",
    "SetReferenceNew",
    "SetStars",
    "SetStars2",
    "SetStarsNew",
    "SetTarget",
    "Standby",
    "StartAO",
    "StepFocus",
    "StopAO",
    "StopGuiding",
    "TipTilt",
    "UpdateNonSiderealObject",
    "UpdateNonSiderealTarget",
    "UpdatePointingReference",
    "UpdateTargetWavelength",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "remove"
};

}

/// \cond INTERNAL
bool
lbto::IIFServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_lbto_IIFServer_all, iceC_lbto_IIFServer_all + 82, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_lbto_IIFServer_all)
    {
        case 0:
        {
            return _iceD_AcquireRefAO(in, current);
        }
        case 1:
        {
            return _iceD_ApplyWaffleAO(in, current);
        }
        case 2:
        {
            return _iceD_Authorize(in, current);
        }
        case 3:
        {
            return _iceD_BinocularControl(in, current);
        }
        case 4:
        {
            return _iceD_CheckRefAO(in, current);
        }
        case 5:
        {
            return _iceD_ClearHotspot(in, current);
        }
        case 6:
        {
            return _iceD_ClearNonSidereal(in, current);
        }
        case 7:
        {
            return _iceD_ClearNonSiderealObject(in, current);
        }
        case 8:
        {
            return _iceD_ClearOffset(in, current);
        }
        case 9:
        {
            return _iceD_ClearReference(in, current);
        }
        case 10:
        {
            return _iceD_ClearStars(in, current);
        }
        case 11:
        {
            return _iceD_CorrectModesAO(in, current);
        }
        case 12:
        {
            return _iceD_GetKFPCoordinates(in, current);
        }
        case 13:
        {
            return _iceD_GetKFPCoordinates2(in, current);
        }
        case 14:
        {
            return _iceD_GetKFPCoordinatesNew(in, current);
        }
        case 15:
        {
            return _iceD_GetParameter(in, current);
        }
        case 16:
        {
            return _iceD_GetRotatorPolynomials(in, current);
        }
        case 17:
        {
            return _iceD_GetRotatorTrajectory(in, current);
        }
        case 18:
        {
            return _iceD_LogEvent(in, current);
        }
        case 19:
        {
            return _iceD_MaximizeWrapTime(in, current);
        }
        case 20:
        {
            return _iceD_ModifyAO(in, current);
        }
        case 21:
        {
            return _iceD_Move(in, current);
        }
        case 22:
        {
            return _iceD_MoveFocus(in, current);
        }
        case 23:
        {
            return _iceD_MoveXY(in, current);
        }
        case 24:
        {
            return _iceD_MoveXYZ(in, current);
        }
        case 25:
        {
            return _iceD_NSQuery(in, current);
        }
        case 26:
        {
            return _iceD_OffsetGuiding(in, current);
        }
        case 27:
        {
            return _iceD_OffsetPointing(in, current);
        }
        case 28:
        {
            return _iceD_OffsetPointing2(in, current);
        }
        case 29:
        {
            return _iceD_OffsetXYAO(in, current);
        }
        case 30:
        {
            return _iceD_OffsetZAO(in, current);
        }
        case 31:
        {
            return _iceD_PauseAO(in, current);
        }
        case 32:
        {
            return _iceD_PauseGuiding(in, current);
        }
        case 33:
        {
            return _iceD_PresetAO(in, current);
        }
        case 34:
        {
            return _iceD_PresetFlatAO(in, current);
        }
        case 35:
        {
            return _iceD_PresetTelescope(in, current);
        }
        case 36:
        {
            return _iceD_RefineAO(in, current);
        }
        case 37:
        {
            return _iceD_ResumeAO(in, current);
        }
        case 38:
        {
            return _iceD_ResumeGuiding(in, current);
        }
        case 39:
        {
            return _iceD_RotHold(in, current);
        }
        case 40:
        {
            return _iceD_RotReady(in, current);
        }
        case 41:
        {
            return _iceD_RotServicePosition(in, current);
        }
        case 42:
        {
            return _iceD_RotTrack(in, current);
        }
        case 43:
        {
            return _iceD_RotateCommon(in, current);
        }
        case 44:
        {
            return _iceD_RotatePrimary(in, current);
        }
        case 45:
        {
            return _iceD_RotateZ(in, current);
        }
        case 46:
        {
            return _iceD_RunAO(in, current);
        }
        case 47:
        {
            return _iceD_SendWavefront(in, current);
        }
        case 48:
        {
            return _iceD_SetAGWFilter(in, current);
        }
        case 49:
        {
            return _iceD_SetGuidingBinning(in, current);
        }
        case 50:
        {
            return _iceD_SetGuidingHotspot(in, current);
        }
        case 51:
        {
            return _iceD_SetHotspot(in, current);
        }
        case 52:
        {
            return _iceD_SetNonSidereal(in, current);
        }
        case 53:
        {
            return _iceD_SetNonSiderealObject(in, current);
        }
        case 54:
        {
            return _iceD_SetOffset(in, current);
        }
        case 55:
        {
            return _iceD_SetOffset2(in, current);
        }
        case 56:
        {
            return _iceD_SetOffsetNew(in, current);
        }
        case 57:
        {
            return _iceD_SetPMTerm(in, current);
        }
        case 58:
        {
            return _iceD_SetPMTerm2(in, current);
        }
        case 59:
        {
            return _iceD_SetParameter(in, current);
        }
        case 60:
        {
            return _iceD_SetReference(in, current);
        }
        case 61:
        {
            return _iceD_SetReference2(in, current);
        }
        case 62:
        {
            return _iceD_SetReferenceNew(in, current);
        }
        case 63:
        {
            return _iceD_SetStars(in, current);
        }
        case 64:
        {
            return _iceD_SetStars2(in, current);
        }
        case 65:
        {
            return _iceD_SetStarsNew(in, current);
        }
        case 66:
        {
            return _iceD_SetTarget(in, current);
        }
        case 67:
        {
            return _iceD_Standby(in, current);
        }
        case 68:
        {
            return _iceD_StartAO(in, current);
        }
        case 69:
        {
            return _iceD_StepFocus(in, current);
        }
        case 70:
        {
            return _iceD_StopAO(in, current);
        }
        case 71:
        {
            return _iceD_StopGuiding(in, current);
        }
        case 72:
        {
            return _iceD_TipTilt(in, current);
        }
        case 73:
        {
            return _iceD_UpdateNonSiderealObject(in, current);
        }
        case 74:
        {
            return _iceD_UpdateNonSiderealTarget(in, current);
        }
        case 75:
        {
            return _iceD_UpdatePointingReference(in, current);
        }
        case 76:
        {
            return _iceD_UpdateTargetWavelength(in, current);
        }
        case 77:
        {
            return _iceD_ice_id(in, current);
        }
        case 78:
        {
            return _iceD_ice_ids(in, current);
        }
        case 79:
        {
            return _iceD_ice_isA(in, current);
        }
        case 80:
        {
            return _iceD_ice_ping(in, current);
        }
        case 81:
        {
            return _iceD_remove(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
lbto::IIFServer::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< IIFServer, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
lbto::IIFServer::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< IIFServer, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
lbto::_icePatchObjectPtr(IIFServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = IIFServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(IIFServer::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
