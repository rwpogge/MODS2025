//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `IIFServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __IIFServer_h__
#define __IIFServer_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace lbto
{

class IIFServer;
class IIFServerPrx;

}

namespace lbto
{

/**
 * @brief Structure to allocate the DD data
 */
struct DDstruct
{
    ::std::string DDname;
    ::std::string DDkey;
    ::std::string dataType;
    ::std::string comment;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(DDname, DDkey, dataType, comment);
    }
};

using SeqDD = ::std::vector<DDstruct>;

/**
 * @brief structure for abbreviated position object
 */
struct position
{
    double coord1;
    double coord2;
    ::std::string system;
    double epoch;
    ::std::string equinox;
    double pmcoord1;
    double pmcoord2;
    double apparentMagnitude;
    ::std::string filter;
    double color;
    ::std::string colorType;
    float wavelength;
    ::std::string targname;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const double&, const double&, const ::std::string&, const double&, const ::std::string&, const double&, const double&, const double&, const ::std::string&, const double&, const ::std::string&, const float&, const ::std::string&> ice_tuple() const
    {
        return std::tie(coord1, coord2, system, epoch, equinox, pmcoord1, pmcoord2, apparentMagnitude, filter, color, colorType, wavelength, targname);
    }
};

using SeqPos = ::std::vector<position>;

/**
 * @brief structure for complete position object. Deprecated; use position2 25-Mar-16
 */
struct newposition
{
    ::std::string type;
    double coord1;
    double coord2;
    ::std::string system;
    ::std::string equinox;
    double epoch;
    double pmcoord1;
    double pmcoord2;
    double apparentMagnitude;
    ::std::string filter;
    double color;
    ::std::string colorType;
    float wavelength;
    ::std::string file;
    double time;
    double RARate;
    double DECRate;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const double&, const double&, const ::std::string&, const ::std::string&, const double&, const double&, const double&, const double&, const ::std::string&, const double&, const ::std::string&, const float&, const ::std::string&, const double&, const double&, const double&> ice_tuple() const
    {
        return std::tie(type, coord1, coord2, system, equinox, epoch, pmcoord1, pmcoord2, apparentMagnitude, filter, color, colorType, wavelength, file, time, RARate, DECRate);
    }
};

using SeqNewPos = ::std::vector<newposition>;

/**
 * @brief structure for complete position object
 */
struct position2
{
    ::std::string type;
    double coord1;
    double coord2;
    ::std::string system;
    double epoch;
    ::std::string equinox;
    double pmcoord1;
    double pmcoord2;
    double apparentMagnitude;
    ::std::string filter;
    double color;
    ::std::string colorType;
    float wavelength;
    ::std::string file;
    double time;
    double RARate;
    double DECRate;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const double&, const double&, const ::std::string&, const double&, const ::std::string&, const double&, const double&, const double&, const ::std::string&, const double&, const ::std::string&, const float&, const ::std::string&, const double&, const double&, const double&> ice_tuple() const
    {
        return std::tie(type, coord1, coord2, system, epoch, equinox, pmcoord1, pmcoord2, apparentMagnitude, filter, color, colorType, wavelength, file, time, RARate, DECRate);
    }
};

using SeqPos2 = ::std::vector<position2>;

/**
 * @brief structure for nonsidereal object
 */
struct nonsidereal
{
    ::std::string type;
    float wavelength;
    ::std::string file;
    double value0;
    double value1;
    double value2;
    double value3;
    double value4;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&, const ::std::string&, const double&, const double&, const double&, const double&, const double&> ice_tuple() const
    {
        return std::tie(type, wavelength, file, value0, value1, value2, value3, value4);
    }
};

/**
 * @brief wavefront vector
 */
using SeqWF = ::std::vector<double>;

/**
 * @brief AO modes vector
 */
using SeqModes = ::std::vector<double>;

/**
 * @brief result vector
 */
using SeqRes = ::std::vector<::std::string>;

/**
 * @brief structure for result object
 */
struct result
{
    int rescode;
    ::lbto::SeqRes resmsg;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::lbto::SeqRes&> ice_tuple() const
    {
        return std::tie(rescode, resmsg);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace lbto
{

/**
 * @brief methods implemented
 */
class IIFServer : public virtual ::Ice::Object
{
public:

    using ProxyType = IIFServerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual result ApplyWaffleAO(SeqModes modes, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ApplyWaffleAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Authorize(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Authorize(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StepFocus(double relPos, ::std::string ope, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StepFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveFocus(double absPos, ::std::string ope, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetPointing(double rotangle, double offx, double offy, ::std::string coordsys, ::std::string ope, ::std::string np, ::std::string movetype, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetPointing(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetPointing2(double rotangle, double offx, double offy, ::std::string coordsys, ::std::string movetype, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetPointing2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetGuiding(double rotangle, double offx, double offy, ::std::string coordsys, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdatePointingReference(::std::string offsetcoord, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdatePointingReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result TipTilt(double xrot, double yrot, ::std::string ope, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_TipTilt(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetPMTerm(::std::string name, double value, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetPMTerm(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetPMTerm2(::std::string name, double value, ::std::string movetype, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetPMTerm2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveXYZ(double xmov, double ymov, double zmov, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveXYZ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveXY(double xmov, double ymov, ::std::string ope, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveXY(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Move(double x, double y, double z, double rx, double ry, double rz, int dflag, ::std::string movetype, ::std::string OPE, int time, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Move(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetTarget(double coord1, double coord2, ::std::string system, double epoch, float wavelength, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStars(SeqPos stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStars(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStarsNew(SeqNewPos stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStarsNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStars2(SeqPos2 stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStars2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearStars(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearStars(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetHotspot(double coord1, double coord2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearHotspot(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffset(double coord1, double coord2, ::std::string system, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffsetNew(double coord1, double coord2, ::std::string system, ::std::string movetype, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffsetNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffset2(double coord1, double coord2, ::std::string system, ::std::string movetype, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffset2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearOffset(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearOffset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetNonSidereal(nonsidereal target, bool override, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetNonSidereal(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearNonSidereal(bool override, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearNonSidereal(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateNonSiderealTarget(double RArate, double DECrate, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateNonSiderealTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetNonSiderealObject(::std::string objtype, nonsidereal target, bool override, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearNonSiderealObject(::std::string objtype, bool override, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateNonSiderealObject(::std::string objtype, double RArate, double DECrate, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetTelescope(double rotangle, ::std::string rotmode, ::std::string mode, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetTelescope(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result BinocularControl(::std::string flag, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_BinocularControl(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetParameter(SeqDD list, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParameter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetParameter(SeqDD list, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetParameter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotateCommon(double z, double angle, double direction, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotateCommon(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotateZ(double angle, ::std::string movetype, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotateZ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotatePrimary(double distance, double angle, double direction, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotatePrimary(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SendWavefront(SeqWF wfs, ::std::string OPE, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendWavefront(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateTargetWavelength(float wavelength, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTargetWavelength(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result LogEvent(::std::string event, ::std::string description, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_LogEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetRotatorTrajectory(double seconds, double interval, double start, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRotatorTrajectory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetRotatorPolynomials(double start, int count, double interval, int order, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRotatorPolynomials(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Standby(int level, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Standby(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MaximizeWrapTime(bool azflag, bool rotflag, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_MaximizeWrapTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PauseGuiding(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ResumeGuiding(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StopGuiding(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StopGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetGuidingHotspot(double coord1, double coord2, ::std::string movetype, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetGuidingHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetAGWFilter(int filterNumber, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetAGWFilter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetGuidingBinning(int factor, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetGuidingBinning(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotReady(bool enable, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotHold(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotHold(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotTrack(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotTrack(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotServicePosition(double angle, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RotServicePosition(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PauseAO(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ResumeAO(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StartAO(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StopAO(::std::string reason, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StopAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result AcquireRefAO(bool repointFlag, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_AcquireRefAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result CheckRefAO(::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_CheckRefAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RefineAO(::std::string method, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RefineAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RunAO(::std::string type, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RunAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetFlatAO(::std::string flat, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetFlatAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result CorrectModesAO(SeqModes modes, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_CorrectModesAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ModifyAO(int NModes, double Freq, int Nbins, double TTMod, ::std::string F1spec, ::std::string F2spec, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ModifyAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetAO(::std::string AOMode, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetXYAO(double DeltaX, double DeltaY, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetXYAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetZAO(double DeltaZ, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetZAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReference(SeqPos stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReferenceNew(SeqNewPos stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReferenceNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReference2(SeqPos2 stars, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReference2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearReference(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinates(SeqPos stars, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinates(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinatesNew(SeqNewPos stars, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinatesNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinates2(SeqPos2 stars, ::std::string side, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinates2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result NSQuery(::std::string targenName, ::std::string startDate, ::std::string startTime, ::std::string endDate, ::std::string endTime, ::std::string interval, ::std::string fileName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_NSQuery(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void remove(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_remove(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace lbto
{

/**
 * @brief methods implemented
 */
class IIFServerPrx : public virtual ::Ice::Proxy<IIFServerPrx, ::Ice::ObjectPrx>
{
public:

    result ApplyWaffleAO(const SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ApplyWaffleAO, modes, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ApplyWaffleAOAsync(const SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ApplyWaffleAO, modes, side, context);
    }

    ::std::function<void()>
    ApplyWaffleAOAsync(const SeqModes& modes, const ::std::string& side,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ApplyWaffleAO, modes, side, context);
    }

    /// \cond INTERNAL
    void _iceI_ApplyWaffleAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqModes&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result Authorize(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_Authorize, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AuthorizeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_Authorize, context);
    }

    ::std::function<void()>
    AuthorizeAsync(::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_Authorize, context);
    }

    /// \cond INTERNAL
    void _iceI_Authorize(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::Ice::Context&);
    /// \endcond

    result StepFocus(double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_StepFocus, relPos, ope, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StepFocusAsync(double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_StepFocus, relPos, ope, side, context);
    }

    ::std::function<void()>
    StepFocusAsync(double relPos, const ::std::string& ope, const ::std::string& side,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_StepFocus, relPos, ope, side, context);
    }

    /// \cond INTERNAL
    void _iceI_StepFocus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result MoveFocus(double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_MoveFocus, absPos, ope, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MoveFocusAsync(double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_MoveFocus, absPos, ope, side, context);
    }

    ::std::function<void()>
    MoveFocusAsync(double absPos, const ::std::string& ope, const ::std::string& side,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_MoveFocus, absPos, ope, side, context);
    }

    /// \cond INTERNAL
    void _iceI_MoveFocus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result OffsetPointing(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_OffsetPointing, rotangle, offx, offy, coordsys, ope, np, movetype, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OffsetPointingAsync(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_OffsetPointing, rotangle, offx, offy, coordsys, ope, np, movetype, side, context);
    }

    ::std::function<void()>
    OffsetPointingAsync(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side,
                        ::std::function<void(::lbto::result)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_OffsetPointing, rotangle, offx, offy, coordsys, ope, np, movetype, side, context);
    }

    /// \cond INTERNAL
    void _iceI_OffsetPointing(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result OffsetPointing2(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_OffsetPointing2, rotangle, offx, offy, coordsys, movetype, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OffsetPointing2Async(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_OffsetPointing2, rotangle, offx, offy, coordsys, movetype, side, context);
    }

    ::std::function<void()>
    OffsetPointing2Async(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side,
                         ::std::function<void(::lbto::result)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_OffsetPointing2, rotangle, offx, offy, coordsys, movetype, side, context);
    }

    /// \cond INTERNAL
    void _iceI_OffsetPointing2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result OffsetGuiding(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_OffsetGuiding, rotangle, offx, offy, coordsys, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OffsetGuidingAsync(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_OffsetGuiding, rotangle, offx, offy, coordsys, side, context);
    }

    ::std::function<void()>
    OffsetGuidingAsync(double rotangle, double offx, double offy, const ::std::string& coordsys, const ::std::string& side,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_OffsetGuiding, rotangle, offx, offy, coordsys, side, context);
    }

    /// \cond INTERNAL
    void _iceI_OffsetGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_UpdatePointingReference, offsetcoord, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdatePointingReferenceAsync(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_UpdatePointingReference, offsetcoord, side, context);
    }

    ::std::function<void()>
    UpdatePointingReferenceAsync(const ::std::string& offsetcoord, const ::std::string& side,
                                 ::std::function<void(::lbto::result)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_UpdatePointingReference, offsetcoord, side, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdatePointingReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result TipTilt(double xrot, double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_TipTilt, xrot, yrot, ope, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto TipTiltAsync(double xrot, double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_TipTilt, xrot, yrot, ope, side, context);
    }

    ::std::function<void()>
    TipTiltAsync(double xrot, double yrot, const ::std::string& ope, const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_TipTilt, xrot, yrot, ope, side, context);
    }

    /// \cond INTERNAL
    void _iceI_TipTilt(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetPMTerm(const ::std::string& name, double value, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetPMTerm, name, value, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetPMTermAsync(const ::std::string& name, double value, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetPMTerm, name, value, side, context);
    }

    ::std::function<void()>
    SetPMTermAsync(const ::std::string& name, double value, const ::std::string& side,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetPMTerm, name, value, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SetPMTerm(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetPMTerm2(const ::std::string& name, double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetPMTerm2, name, value, movetype, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetPMTerm2Async(const ::std::string& name, double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetPMTerm2, name, value, movetype, side, context);
    }

    ::std::function<void()>
    SetPMTerm2Async(const ::std::string& name, double value, const ::std::string& movetype, const ::std::string& side,
                    ::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetPMTerm2, name, value, movetype, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SetPMTerm2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result MoveXYZ(double xmov, double ymov, double zmov, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_MoveXYZ, xmov, ymov, zmov, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MoveXYZAsync(double xmov, double ymov, double zmov, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_MoveXYZ, xmov, ymov, zmov, side, context);
    }

    ::std::function<void()>
    MoveXYZAsync(double xmov, double ymov, double zmov, const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_MoveXYZ, xmov, ymov, zmov, side, context);
    }

    /// \cond INTERNAL
    void _iceI_MoveXYZ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result MoveXY(double xmov, double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_MoveXY, xmov, ymov, ope, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MoveXYAsync(double xmov, double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_MoveXY, xmov, ymov, ope, side, context);
    }

    ::std::function<void()>
    MoveXYAsync(double xmov, double ymov, const ::std::string& ope, const ::std::string& side,
                ::std::function<void(::lbto::result)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_MoveXY, xmov, ymov, ope, side, context);
    }

    /// \cond INTERNAL
    void _iceI_MoveXY(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result Move(double x, double y, double z, double rx, double ry, double rz, int dflag, const ::std::string& movetype, const ::std::string& OPE, int time, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_Move, x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MoveAsync(double x, double y, double z, double rx, double ry, double rz, int dflag, const ::std::string& movetype, const ::std::string& OPE, int time, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_Move, x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context);
    }

    ::std::function<void()>
    MoveAsync(double x, double y, double z, double rx, double ry, double rz, int dflag, const ::std::string& movetype, const ::std::string& OPE, int time, const ::std::string& side,
              ::std::function<void(::lbto::result)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_Move, x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context);
    }

    /// \cond INTERNAL
    void _iceI_Move(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, double, double, double, int, const ::std::string&, const ::std::string&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetTarget(double coord1, double coord2, const ::std::string& system, double epoch, float wavelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetTarget, coord1, coord2, system, epoch, wavelength, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetTargetAsync(double coord1, double coord2, const ::std::string& system, double epoch, float wavelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetTarget, coord1, coord2, system, epoch, wavelength, context);
    }

    ::std::function<void()>
    SetTargetAsync(double coord1, double coord2, const ::std::string& system, double epoch, float wavelength,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetTarget, coord1, coord2, system, epoch, wavelength, context);
    }

    /// \cond INTERNAL
    void _iceI_SetTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, double, float, const ::Ice::Context&);
    /// \endcond

    result SetStars(const SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetStars, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetStarsAsync(const SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetStars, stars, context);
    }

    ::std::function<void()>
    SetStarsAsync(const SeqPos& stars,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetStars, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetStars(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos&, const ::Ice::Context&);
    /// \endcond

    result SetStarsNew(const SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetStarsNew, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetStarsNewAsync(const SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetStarsNew, stars, context);
    }

    ::std::function<void()>
    SetStarsNewAsync(const SeqNewPos& stars,
                     ::std::function<void(::lbto::result)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetStarsNew, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetStarsNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqNewPos&, const ::Ice::Context&);
    /// \endcond

    result SetStars2(const SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetStars2, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetStars2Async(const SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetStars2, stars, context);
    }

    ::std::function<void()>
    SetStars2Async(const SeqPos2& stars,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetStars2, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetStars2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos2&, const ::Ice::Context&);
    /// \endcond

    result ClearStars(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearStars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearStarsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearStars, context);
    }

    ::std::function<void()>
    ClearStarsAsync(::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearStars, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearStars(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::Ice::Context&);
    /// \endcond

    result SetHotspot(double coord1, double coord2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetHotspot, coord1, coord2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetHotspotAsync(double coord1, double coord2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetHotspot, coord1, coord2, context);
    }

    ::std::function<void()>
    SetHotspotAsync(double coord1, double coord2,
                    ::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetHotspot, coord1, coord2, context);
    }

    /// \cond INTERNAL
    void _iceI_SetHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::Ice::Context&);
    /// \endcond

    result ClearHotspot(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearHotspot, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearHotspotAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearHotspot, context);
    }

    ::std::function<void()>
    ClearHotspotAsync(::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearHotspot, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::Ice::Context&);
    /// \endcond

    result SetOffset(double coord1, double coord2, const ::std::string& system, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetOffset, coord1, coord2, system, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetOffsetAsync(double coord1, double coord2, const ::std::string& system, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetOffset, coord1, coord2, system, context);
    }

    ::std::function<void()>
    SetOffsetAsync(double coord1, double coord2, const ::std::string& system,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetOffset, coord1, coord2, system, context);
    }

    /// \cond INTERNAL
    void _iceI_SetOffset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetOffsetNew(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetOffsetNew, coord1, coord2, system, movetype, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetOffsetNewAsync(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetOffsetNew, coord1, coord2, system, movetype, context);
    }

    ::std::function<void()>
    SetOffsetNewAsync(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetOffsetNew, coord1, coord2, system, movetype, context);
    }

    /// \cond INTERNAL
    void _iceI_SetOffsetNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetOffset2(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetOffset2, coord1, coord2, system, movetype, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetOffset2Async(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetOffset2, coord1, coord2, system, movetype, context);
    }

    ::std::function<void()>
    SetOffset2Async(double coord1, double coord2, const ::std::string& system, const ::std::string& movetype,
                    ::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetOffset2, coord1, coord2, system, movetype, context);
    }

    /// \cond INTERNAL
    void _iceI_SetOffset2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result ClearOffset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearOffset, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearOffsetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearOffset, context);
    }

    ::std::function<void()>
    ClearOffsetAsync(::std::function<void(::lbto::result)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearOffset, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearOffset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::Ice::Context&);
    /// \endcond

    result SetNonSidereal(const nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetNonSidereal, target, override, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetNonSiderealAsync(const nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetNonSidereal, target, override, context);
    }

    ::std::function<void()>
    SetNonSiderealAsync(const nonsidereal& target, bool override,
                        ::std::function<void(::lbto::result)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetNonSidereal, target, override, context);
    }

    /// \cond INTERNAL
    void _iceI_SetNonSidereal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const nonsidereal&, bool, const ::Ice::Context&);
    /// \endcond

    result ClearNonSidereal(bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearNonSidereal, override, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearNonSiderealAsync(bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearNonSidereal, override, context);
    }

    ::std::function<void()>
    ClearNonSiderealAsync(bool override,
                          ::std::function<void(::lbto::result)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearNonSidereal, override, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearNonSidereal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, bool, const ::Ice::Context&);
    /// \endcond

    result UpdateNonSiderealTarget(double RArate, double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_UpdateNonSiderealTarget, RArate, DECrate, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateNonSiderealTargetAsync(double RArate, double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_UpdateNonSiderealTarget, RArate, DECrate, context);
    }

    ::std::function<void()>
    UpdateNonSiderealTargetAsync(double RArate, double DECrate,
                                 ::std::function<void(::lbto::result)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_UpdateNonSiderealTarget, RArate, DECrate, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateNonSiderealTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::Ice::Context&);
    /// \endcond

    result SetNonSiderealObject(const ::std::string& objtype, const nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetNonSiderealObject, objtype, target, override, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetNonSiderealObjectAsync(const ::std::string& objtype, const nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetNonSiderealObject, objtype, target, override, context);
    }

    ::std::function<void()>
    SetNonSiderealObjectAsync(const ::std::string& objtype, const nonsidereal& target, bool override,
                              ::std::function<void(::lbto::result)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetNonSiderealObject, objtype, target, override, context);
    }

    /// \cond INTERNAL
    void _iceI_SetNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const nonsidereal&, bool, const ::Ice::Context&);
    /// \endcond

    result ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearNonSiderealObject, objtype, override, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearNonSiderealObjectAsync(const ::std::string& objtype, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearNonSiderealObject, objtype, override, context);
    }

    ::std::function<void()>
    ClearNonSiderealObjectAsync(const ::std::string& objtype, bool override,
                                ::std::function<void(::lbto::result)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearNonSiderealObject, objtype, override, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, bool, const ::Ice::Context&);
    /// \endcond

    result UpdateNonSiderealObject(const ::std::string& objtype, double RArate, double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_UpdateNonSiderealObject, objtype, RArate, DECrate, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateNonSiderealObjectAsync(const ::std::string& objtype, double RArate, double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_UpdateNonSiderealObject, objtype, RArate, DECrate, context);
    }

    ::std::function<void()>
    UpdateNonSiderealObjectAsync(const ::std::string& objtype, double RArate, double DECrate,
                                 ::std::function<void(::lbto::result)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_UpdateNonSiderealObject, objtype, RArate, DECrate, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateNonSiderealObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, double, double, const ::Ice::Context&);
    /// \endcond

    result PresetTelescope(double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_PresetTelescope, rotangle, rotmode, mode, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PresetTelescopeAsync(double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_PresetTelescope, rotangle, rotmode, mode, side, context);
    }

    ::std::function<void()>
    PresetTelescopeAsync(double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side,
                         ::std::function<void(::lbto::result)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_PresetTelescope, rotangle, rotmode, mode, side, context);
    }

    /// \cond INTERNAL
    void _iceI_PresetTelescope(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result BinocularControl(const ::std::string& flag, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_BinocularControl, flag, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto BinocularControlAsync(const ::std::string& flag, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_BinocularControl, flag, context);
    }

    ::std::function<void()>
    BinocularControlAsync(const ::std::string& flag,
                          ::std::function<void(::lbto::result)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_BinocularControl, flag, context);
    }

    /// \cond INTERNAL
    void _iceI_BinocularControl(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result GetParameter(const SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetParameter, list, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetParameterAsync(const SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetParameter, list, context);
    }

    ::std::function<void()>
    GetParameterAsync(const SeqDD& list,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetParameter, list, context);
    }

    /// \cond INTERNAL
    void _iceI_GetParameter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqDD&, const ::Ice::Context&);
    /// \endcond

    result SetParameter(const SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetParameter, list, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetParameterAsync(const SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetParameter, list, context);
    }

    ::std::function<void()>
    SetParameterAsync(const SeqDD& list,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetParameter, list, context);
    }

    /// \cond INTERNAL
    void _iceI_SetParameter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqDD&, const ::Ice::Context&);
    /// \endcond

    result RotateCommon(double z, double angle, double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotateCommon, z, angle, direction, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotateCommonAsync(double z, double angle, double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotateCommon, z, angle, direction, side, context);
    }

    ::std::function<void()>
    RotateCommonAsync(double z, double angle, double direction, const ::std::string& side,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotateCommon, z, angle, direction, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotateCommon(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotateZ(double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotateZ, angle, movetype, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotateZAsync(double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotateZ, angle, movetype, side, context);
    }

    ::std::function<void()>
    RotateZAsync(double angle, const ::std::string& movetype, const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotateZ, angle, movetype, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotateZ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotatePrimary(double distance, double angle, double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotatePrimary, distance, angle, direction, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotatePrimaryAsync(double distance, double angle, double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotatePrimary, distance, angle, direction, side, context);
    }

    ::std::function<void()>
    RotatePrimaryAsync(double distance, double angle, double direction, const ::std::string& side,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotatePrimary, distance, angle, direction, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotatePrimary(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SendWavefront(const SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SendWavefront, wfs, OPE, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendWavefrontAsync(const SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SendWavefront, wfs, OPE, side, context);
    }

    ::std::function<void()>
    SendWavefrontAsync(const SeqWF& wfs, const ::std::string& OPE, const ::std::string& side,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SendWavefront, wfs, OPE, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SendWavefront(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqWF&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result UpdateTargetWavelength(float wavelength, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_UpdateTargetWavelength, wavelength, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UpdateTargetWavelengthAsync(float wavelength, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_UpdateTargetWavelength, wavelength, side, context);
    }

    ::std::function<void()>
    UpdateTargetWavelengthAsync(float wavelength, const ::std::string& side,
                                ::std::function<void(::lbto::result)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_UpdateTargetWavelength, wavelength, side, context);
    }

    /// \cond INTERNAL
    void _iceI_UpdateTargetWavelength(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, float, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_LogEvent, event, description, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LogEventAsync(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_LogEvent, event, description, context);
    }

    ::std::function<void()>
    LogEventAsync(const ::std::string& event, const ::std::string& description,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_LogEvent, event, description, context);
    }

    /// \cond INTERNAL
    void _iceI_LogEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result GetRotatorTrajectory(double seconds, double interval, double start, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetRotatorTrajectory, seconds, interval, start, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetRotatorTrajectoryAsync(double seconds, double interval, double start, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetRotatorTrajectory, seconds, interval, start, side, context);
    }

    ::std::function<void()>
    GetRotatorTrajectoryAsync(double seconds, double interval, double start, const ::std::string& side,
                              ::std::function<void(::lbto::result)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetRotatorTrajectory, seconds, interval, start, side, context);
    }

    /// \cond INTERNAL
    void _iceI_GetRotatorTrajectory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result GetRotatorPolynomials(double start, int count, double interval, int order, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetRotatorPolynomials, start, count, interval, order, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetRotatorPolynomialsAsync(double start, int count, double interval, int order, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetRotatorPolynomials, start, count, interval, order, side, context);
    }

    ::std::function<void()>
    GetRotatorPolynomialsAsync(double start, int count, double interval, int order, const ::std::string& side,
                               ::std::function<void(::lbto::result)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetRotatorPolynomials, start, count, interval, order, side, context);
    }

    /// \cond INTERNAL
    void _iceI_GetRotatorPolynomials(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, int, double, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result Standby(int level, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_Standby, level, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StandbyAsync(int level, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_Standby, level, side, context);
    }

    ::std::function<void()>
    StandbyAsync(int level, const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_Standby, level, side, context);
    }

    /// \cond INTERNAL
    void _iceI_Standby(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_MaximizeWrapTime, azflag, rotflag, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MaximizeWrapTimeAsync(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_MaximizeWrapTime, azflag, rotflag, side, context);
    }

    ::std::function<void()>
    MaximizeWrapTimeAsync(bool azflag, bool rotflag, const ::std::string& side,
                          ::std::function<void(::lbto::result)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_MaximizeWrapTime, azflag, rotflag, side, context);
    }

    /// \cond INTERNAL
    void _iceI_MaximizeWrapTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, bool, bool, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result PauseGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_PauseGuiding, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PauseGuidingAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_PauseGuiding, side, context);
    }

    ::std::function<void()>
    PauseGuidingAsync(const ::std::string& side,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_PauseGuiding, side, context);
    }

    /// \cond INTERNAL
    void _iceI_PauseGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result ResumeGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ResumeGuiding, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ResumeGuidingAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ResumeGuiding, side, context);
    }

    ::std::function<void()>
    ResumeGuidingAsync(const ::std::string& side,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ResumeGuiding, side, context);
    }

    /// \cond INTERNAL
    void _iceI_ResumeGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result StopGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_StopGuiding, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StopGuidingAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_StopGuiding, side, context);
    }

    ::std::function<void()>
    StopGuidingAsync(const ::std::string& side,
                     ::std::function<void(::lbto::result)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_StopGuiding, side, context);
    }

    /// \cond INTERNAL
    void _iceI_StopGuiding(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetGuidingHotspot(double coord1, double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetGuidingHotspot, coord1, coord2, movetype, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetGuidingHotspotAsync(double coord1, double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetGuidingHotspot, coord1, coord2, movetype, side, context);
    }

    ::std::function<void()>
    SetGuidingHotspotAsync(double coord1, double coord2, const ::std::string& movetype, const ::std::string& side,
                           ::std::function<void(::lbto::result)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetGuidingHotspot, coord1, coord2, movetype, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SetGuidingHotspot(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetAGWFilter(int filterNumber, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetAGWFilter, filterNumber, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetAGWFilterAsync(int filterNumber, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetAGWFilter, filterNumber, side, context);
    }

    ::std::function<void()>
    SetAGWFilterAsync(int filterNumber, const ::std::string& side,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetAGWFilter, filterNumber, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SetAGWFilter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetGuidingBinning(int factor, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetGuidingBinning, factor, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetGuidingBinningAsync(int factor, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetGuidingBinning, factor, side, context);
    }

    ::std::function<void()>
    SetGuidingBinningAsync(int factor, const ::std::string& side,
                           ::std::function<void(::lbto::result)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetGuidingBinning, factor, side, context);
    }

    /// \cond INTERNAL
    void _iceI_SetGuidingBinning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotReady(bool enable, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotReady, enable, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotReadyAsync(bool enable, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotReady, enable, side, context);
    }

    ::std::function<void()>
    RotReadyAsync(bool enable, const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotReady, enable, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotReady(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, bool, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotHold(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotHold, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotHoldAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotHold, side, context);
    }

    ::std::function<void()>
    RotHoldAsync(const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotHold, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotHold(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotTrack(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotTrack, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotTrackAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotTrack, side, context);
    }

    ::std::function<void()>
    RotTrackAsync(const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotTrack, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotTrack(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RotServicePosition(double angle, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RotServicePosition, angle, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RotServicePositionAsync(double angle, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RotServicePosition, angle, side, context);
    }

    ::std::function<void()>
    RotServicePositionAsync(double angle, const ::std::string& side,
                            ::std::function<void(::lbto::result)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RotServicePosition, angle, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RotServicePosition(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result PauseAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_PauseAO, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PauseAOAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_PauseAO, side, context);
    }

    ::std::function<void()>
    PauseAOAsync(const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_PauseAO, side, context);
    }

    /// \cond INTERNAL
    void _iceI_PauseAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result ResumeAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ResumeAO, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ResumeAOAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ResumeAO, side, context);
    }

    ::std::function<void()>
    ResumeAOAsync(const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ResumeAO, side, context);
    }

    /// \cond INTERNAL
    void _iceI_ResumeAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result StartAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_StartAO, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartAOAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_StartAO, side, context);
    }

    ::std::function<void()>
    StartAOAsync(const ::std::string& side,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_StartAO, side, context);
    }

    /// \cond INTERNAL
    void _iceI_StartAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_StopAO, reason, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StopAOAsync(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_StopAO, reason, side, context);
    }

    ::std::function<void()>
    StopAOAsync(const ::std::string& reason, const ::std::string& side,
                ::std::function<void(::lbto::result)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_StopAO, reason, side, context);
    }

    /// \cond INTERNAL
    void _iceI_StopAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_AcquireRefAO, repointFlag, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AcquireRefAOAsync(bool repointFlag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_AcquireRefAO, repointFlag, side, context);
    }

    ::std::function<void()>
    AcquireRefAOAsync(bool repointFlag, const ::std::string& side,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_AcquireRefAO, repointFlag, side, context);
    }

    /// \cond INTERNAL
    void _iceI_AcquireRefAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, bool, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result CheckRefAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_CheckRefAO, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto CheckRefAOAsync(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_CheckRefAO, side, context);
    }

    ::std::function<void()>
    CheckRefAOAsync(const ::std::string& side,
                    ::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_CheckRefAO, side, context);
    }

    /// \cond INTERNAL
    void _iceI_CheckRefAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RefineAO, method, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RefineAOAsync(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RefineAO, method, side, context);
    }

    ::std::function<void()>
    RefineAOAsync(const ::std::string& method, const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RefineAO, method, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RefineAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_RunAO, type, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RunAOAsync(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_RunAO, type, side, context);
    }

    ::std::function<void()>
    RunAOAsync(const ::std::string& type, const ::std::string& side,
               ::std::function<void(::lbto::result)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_RunAO, type, side, context);
    }

    /// \cond INTERNAL
    void _iceI_RunAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_PresetFlatAO, flat, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PresetFlatAOAsync(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_PresetFlatAO, flat, side, context);
    }

    ::std::function<void()>
    PresetFlatAOAsync(const ::std::string& flat, const ::std::string& side,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_PresetFlatAO, flat, side, context);
    }

    /// \cond INTERNAL
    void _iceI_PresetFlatAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result CorrectModesAO(const SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_CorrectModesAO, modes, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto CorrectModesAOAsync(const SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_CorrectModesAO, modes, side, context);
    }

    ::std::function<void()>
    CorrectModesAOAsync(const SeqModes& modes, const ::std::string& side,
                        ::std::function<void(::lbto::result)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_CorrectModesAO, modes, side, context);
    }

    /// \cond INTERNAL
    void _iceI_CorrectModesAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqModes&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result ModifyAO(int NModes, double Freq, int Nbins, double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ModifyAO, NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ModifyAOAsync(int NModes, double Freq, int Nbins, double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ModifyAO, NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context);
    }

    ::std::function<void()>
    ModifyAOAsync(int NModes, double Freq, int Nbins, double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ModifyAO, NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context);
    }

    /// \cond INTERNAL
    void _iceI_ModifyAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, int, double, int, double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_PresetAO, AOMode, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PresetAOAsync(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_PresetAO, AOMode, side, context);
    }

    ::std::function<void()>
    PresetAOAsync(const ::std::string& AOMode, const ::std::string& side,
                  ::std::function<void(::lbto::result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_PresetAO, AOMode, side, context);
    }

    /// \cond INTERNAL
    void _iceI_PresetAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result OffsetXYAO(double DeltaX, double DeltaY, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_OffsetXYAO, DeltaX, DeltaY, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OffsetXYAOAsync(double DeltaX, double DeltaY, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_OffsetXYAO, DeltaX, DeltaY, side, context);
    }

    ::std::function<void()>
    OffsetXYAOAsync(double DeltaX, double DeltaY, const ::std::string& side,
                    ::std::function<void(::lbto::result)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_OffsetXYAO, DeltaX, DeltaY, side, context);
    }

    /// \cond INTERNAL
    void _iceI_OffsetXYAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result OffsetZAO(double DeltaZ, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_OffsetZAO, DeltaZ, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OffsetZAOAsync(double DeltaZ, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_OffsetZAO, DeltaZ, side, context);
    }

    ::std::function<void()>
    OffsetZAOAsync(double DeltaZ, const ::std::string& side,
                   ::std::function<void(::lbto::result)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_OffsetZAO, DeltaZ, side, context);
    }

    /// \cond INTERNAL
    void _iceI_OffsetZAO(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, double, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result SetReference(const SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetReference, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetReferenceAsync(const SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetReference, stars, context);
    }

    ::std::function<void()>
    SetReferenceAsync(const SeqPos& stars,
                      ::std::function<void(::lbto::result)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetReference, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos&, const ::Ice::Context&);
    /// \endcond

    result SetReferenceNew(const SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetReferenceNew, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetReferenceNewAsync(const SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetReferenceNew, stars, context);
    }

    ::std::function<void()>
    SetReferenceNewAsync(const SeqNewPos& stars,
                         ::std::function<void(::lbto::result)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetReferenceNew, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetReferenceNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqNewPos&, const ::Ice::Context&);
    /// \endcond

    result SetReference2(const SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_SetReference2, stars, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetReference2Async(const SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_SetReference2, stars, context);
    }

    ::std::function<void()>
    SetReference2Async(const SeqPos2& stars,
                       ::std::function<void(::lbto::result)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_SetReference2, stars, context);
    }

    /// \cond INTERNAL
    void _iceI_SetReference2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos2&, const ::Ice::Context&);
    /// \endcond

    result ClearReference(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_ClearReference, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearReferenceAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_ClearReference, context);
    }

    ::std::function<void()>
    ClearReferenceAsync(::std::function<void(::lbto::result)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_ClearReference, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearReference(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::Ice::Context&);
    /// \endcond

    result GetKFPCoordinates(const SeqPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetKFPCoordinates, stars, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKFPCoordinatesAsync(const SeqPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetKFPCoordinates, stars, side, context);
    }

    ::std::function<void()>
    GetKFPCoordinatesAsync(const SeqPos& stars, const ::std::string& side,
                           ::std::function<void(::lbto::result)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetKFPCoordinates, stars, side, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKFPCoordinates(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result GetKFPCoordinatesNew(const SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetKFPCoordinatesNew, stars, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKFPCoordinatesNewAsync(const SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetKFPCoordinatesNew, stars, side, context);
    }

    ::std::function<void()>
    GetKFPCoordinatesNewAsync(const SeqNewPos& stars, const ::std::string& side,
                              ::std::function<void(::lbto::result)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetKFPCoordinatesNew, stars, side, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKFPCoordinatesNew(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqNewPos&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result GetKFPCoordinates2(const SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_GetKFPCoordinates2, stars, side, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetKFPCoordinates2Async(const SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_GetKFPCoordinates2, stars, side, context);
    }

    ::std::function<void()>
    GetKFPCoordinates2Async(const SeqPos2& stars, const ::std::string& side,
                            ::std::function<void(::lbto::result)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_GetKFPCoordinates2, stars, side, context);
    }

    /// \cond INTERNAL
    void _iceI_GetKFPCoordinates2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const SeqPos2&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    result NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::lbto::result>(true, this, &IIFServerPrx::_iceI_NSQuery, targenName, startDate, startTime, endDate, endTime, interval, fileName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto NSQueryAsync(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::lbto::result>>().get_future())
    {
        return _makePromiseOutgoing<::lbto::result, P>(false, this, &IIFServerPrx::_iceI_NSQuery, targenName, startDate, startTime, endDate, endTime, interval, fileName, context);
    }

    ::std::function<void()>
    NSQueryAsync(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName,
                 ::std::function<void(::lbto::result)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::lbto::result>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_NSQuery, targenName, startDate, startTime, endDate, endTime, interval, fileName, context);
    }

    /// \cond INTERNAL
    void _iceI_NSQuery(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::lbto::result>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void remove(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IIFServerPrx::_iceI_remove, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IIFServerPrx::_iceI_remove, context);
    }

    ::std::function<void()>
    removeAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &lbto::IIFServerPrx::_iceI_remove, context);
    }

    /// \cond INTERNAL
    void _iceI_remove(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IIFServerPrx() = default;
    friend ::std::shared_ptr<IIFServerPrx> IceInternal::createProxy<IIFServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::lbto::DDstruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::DDstruct, S>
{
    static void read(S* istr, ::lbto::DDstruct& v)
    {
        istr->readAll(v.DDname, v.DDkey, v.dataType, v.comment);
    }
};

template<>
struct StreamableTraits<::lbto::position>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 65;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::position, S>
{
    static void read(S* istr, ::lbto::position& v)
    {
        istr->readAll(v.coord1, v.coord2, v.system, v.epoch, v.equinox, v.pmcoord1, v.pmcoord2, v.apparentMagnitude, v.filter, v.color, v.colorType, v.wavelength, v.targname);
    }
};

template<>
struct StreamableTraits<::lbto::newposition>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 90;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::newposition, S>
{
    static void read(S* istr, ::lbto::newposition& v)
    {
        istr->readAll(v.type, v.coord1, v.coord2, v.system, v.equinox, v.epoch, v.pmcoord1, v.pmcoord2, v.apparentMagnitude, v.filter, v.color, v.colorType, v.wavelength, v.file, v.time, v.RARate, v.DECRate);
    }
};

template<>
struct StreamableTraits<::lbto::position2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 90;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::position2, S>
{
    static void read(S* istr, ::lbto::position2& v)
    {
        istr->readAll(v.type, v.coord1, v.coord2, v.system, v.epoch, v.equinox, v.pmcoord1, v.pmcoord2, v.apparentMagnitude, v.filter, v.color, v.colorType, v.wavelength, v.file, v.time, v.RARate, v.DECRate);
    }
};

template<>
struct StreamableTraits<::lbto::nonsidereal>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 46;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::nonsidereal, S>
{
    static void read(S* istr, ::lbto::nonsidereal& v)
    {
        istr->readAll(v.type, v.wavelength, v.file, v.value0, v.value1, v.value2, v.value3, v.value4);
    }
};

template<>
struct StreamableTraits<::lbto::result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::lbto::result, S>
{
    static void read(S* istr, ::lbto::result& v)
    {
        istr->readAll(v.rescode, v.resmsg);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace lbto
{

using IIFServerPtr = ::std::shared_ptr<IIFServer>;
using IIFServerPrxPtr = ::std::shared_ptr<IIFServerPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace lbto
{

class IIFServer;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< IIFServer>&);
::IceProxy::Ice::Object* upCast(IIFServer*);
/// \endcond

}

}

namespace lbto
{

class IIFServer;
/// \cond INTERNAL
::Ice::Object* upCast(IIFServer*);
/// \endcond
typedef ::IceInternal::Handle< IIFServer> IIFServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::lbto::IIFServer> IIFServerPrx;
typedef IIFServerPrx IIFServerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IIFServerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace lbto
{

/**
 * @brief Structure to allocate the DD data
 */
struct DDstruct
{
    ::std::string DDname;
    ::std::string DDkey;
    ::std::string dataType;
    ::std::string comment;

    bool operator==(const DDstruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(DDname != rhs_.DDname)
        {
            return false;
        }
        if(DDkey != rhs_.DDkey)
        {
            return false;
        }
        if(dataType != rhs_.dataType)
        {
            return false;
        }
        if(comment != rhs_.comment)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DDstruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(DDname < rhs_.DDname)
        {
            return true;
        }
        else if(rhs_.DDname < DDname)
        {
            return false;
        }
        if(DDkey < rhs_.DDkey)
        {
            return true;
        }
        else if(rhs_.DDkey < DDkey)
        {
            return false;
        }
        if(dataType < rhs_.dataType)
        {
            return true;
        }
        else if(rhs_.dataType < dataType)
        {
            return false;
        }
        if(comment < rhs_.comment)
        {
            return true;
        }
        else if(rhs_.comment < comment)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DDstruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const DDstruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const DDstruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const DDstruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<DDstruct> SeqDD;

/**
 * @brief structure for abbreviated position object
 */
struct position
{
    ::Ice::Double coord1;
    ::Ice::Double coord2;
    ::std::string system;
    ::Ice::Double epoch;
    ::std::string equinox;
    ::Ice::Double pmcoord1;
    ::Ice::Double pmcoord2;
    ::Ice::Double apparentMagnitude;
    ::std::string filter;
    ::Ice::Double color;
    ::std::string colorType;
    ::Ice::Float wavelength;
    ::std::string targname;
};

typedef ::std::vector<position> SeqPos;

/**
 * @brief structure for complete position object. Deprecated; use position2 25-Mar-16
 */
struct newposition
{
    ::std::string type;
    ::Ice::Double coord1;
    ::Ice::Double coord2;
    ::std::string system;
    ::std::string equinox;
    ::Ice::Double epoch;
    ::Ice::Double pmcoord1;
    ::Ice::Double pmcoord2;
    ::Ice::Double apparentMagnitude;
    ::std::string filter;
    ::Ice::Double color;
    ::std::string colorType;
    ::Ice::Float wavelength;
    ::std::string file;
    ::Ice::Double time;
    ::Ice::Double RARate;
    ::Ice::Double DECRate;
};

typedef ::std::vector<newposition> SeqNewPos;

/**
 * @brief structure for complete position object
 */
struct position2
{
    ::std::string type;
    ::Ice::Double coord1;
    ::Ice::Double coord2;
    ::std::string system;
    ::Ice::Double epoch;
    ::std::string equinox;
    ::Ice::Double pmcoord1;
    ::Ice::Double pmcoord2;
    ::Ice::Double apparentMagnitude;
    ::std::string filter;
    ::Ice::Double color;
    ::std::string colorType;
    ::Ice::Float wavelength;
    ::std::string file;
    ::Ice::Double time;
    ::Ice::Double RARate;
    ::Ice::Double DECRate;
};

typedef ::std::vector<position2> SeqPos2;

/**
 * @brief structure for nonsidereal object
 */
struct nonsidereal
{
    ::std::string type;
    ::Ice::Float wavelength;
    ::std::string file;
    ::Ice::Double value0;
    ::Ice::Double value1;
    ::Ice::Double value2;
    ::Ice::Double value3;
    ::Ice::Double value4;
};

/**
 * @brief wavefront vector
 */
typedef ::std::vector< ::Ice::Double> SeqWF;

/**
 * @brief AO modes vector
 */
typedef ::std::vector< ::Ice::Double> SeqModes;

/**
 * @brief result vector
 */
typedef ::std::vector< ::std::string> SeqRes;

/**
 * @brief structure for result object
 */
struct result
{
    ::Ice::Int rescode;
    ::lbto::SeqRes resmsg;
};

}

namespace lbto
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ApplyWaffleAO.
 */
class Callback_IIFServer_ApplyWaffleAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ApplyWaffleAO_Base> Callback_IIFServer_ApplyWaffleAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_Authorize.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Authorize.
 */
class Callback_IIFServer_Authorize_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_Authorize_Base> Callback_IIFServer_AuthorizePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_StepFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StepFocus.
 */
class Callback_IIFServer_StepFocus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_StepFocus_Base> Callback_IIFServer_StepFocusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveFocus.
 */
class Callback_IIFServer_MoveFocus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_MoveFocus_Base> Callback_IIFServer_MoveFocusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing.
 */
class Callback_IIFServer_OffsetPointing_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_OffsetPointing_Base> Callback_IIFServer_OffsetPointingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing2.
 */
class Callback_IIFServer_OffsetPointing2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_OffsetPointing2_Base> Callback_IIFServer_OffsetPointing2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetGuiding.
 */
class Callback_IIFServer_OffsetGuiding_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_OffsetGuiding_Base> Callback_IIFServer_OffsetGuidingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdatePointingReference.
 */
class Callback_IIFServer_UpdatePointingReference_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_UpdatePointingReference_Base> Callback_IIFServer_UpdatePointingReferencePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_TipTilt.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_TipTilt.
 */
class Callback_IIFServer_TipTilt_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_TipTilt_Base> Callback_IIFServer_TipTiltPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm.
 */
class Callback_IIFServer_SetPMTerm_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetPMTerm_Base> Callback_IIFServer_SetPMTermPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm2.
 */
class Callback_IIFServer_SetPMTerm2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetPMTerm2_Base> Callback_IIFServer_SetPMTerm2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXYZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXYZ.
 */
class Callback_IIFServer_MoveXYZ_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_MoveXYZ_Base> Callback_IIFServer_MoveXYZPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXY.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXY.
 */
class Callback_IIFServer_MoveXY_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_MoveXY_Base> Callback_IIFServer_MoveXYPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_Move.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Move.
 */
class Callback_IIFServer_Move_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_Move_Base> Callback_IIFServer_MovePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetTarget.
 */
class Callback_IIFServer_SetTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetTarget_Base> Callback_IIFServer_SetTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars.
 */
class Callback_IIFServer_SetStars_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetStars_Base> Callback_IIFServer_SetStarsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStarsNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStarsNew.
 */
class Callback_IIFServer_SetStarsNew_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetStarsNew_Base> Callback_IIFServer_SetStarsNewPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars2.
 */
class Callback_IIFServer_SetStars2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetStars2_Base> Callback_IIFServer_SetStars2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearStars.
 */
class Callback_IIFServer_ClearStars_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearStars_Base> Callback_IIFServer_ClearStarsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetHotspot.
 */
class Callback_IIFServer_SetHotspot_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetHotspot_Base> Callback_IIFServer_SetHotspotPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearHotspot.
 */
class Callback_IIFServer_ClearHotspot_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearHotspot_Base> Callback_IIFServer_ClearHotspotPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset.
 */
class Callback_IIFServer_SetOffset_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetOffset_Base> Callback_IIFServer_SetOffsetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffsetNew.
 */
class Callback_IIFServer_SetOffsetNew_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetOffsetNew_Base> Callback_IIFServer_SetOffsetNewPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset2.
 */
class Callback_IIFServer_SetOffset2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetOffset2_Base> Callback_IIFServer_SetOffset2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearOffset.
 */
class Callback_IIFServer_ClearOffset_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearOffset_Base> Callback_IIFServer_ClearOffsetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSidereal.
 */
class Callback_IIFServer_SetNonSidereal_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetNonSidereal_Base> Callback_IIFServer_SetNonSiderealPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSidereal.
 */
class Callback_IIFServer_ClearNonSidereal_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearNonSidereal_Base> Callback_IIFServer_ClearNonSiderealPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealTarget.
 */
class Callback_IIFServer_UpdateNonSiderealTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_UpdateNonSiderealTarget_Base> Callback_IIFServer_UpdateNonSiderealTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSiderealObject.
 */
class Callback_IIFServer_SetNonSiderealObject_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetNonSiderealObject_Base> Callback_IIFServer_SetNonSiderealObjectPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSiderealObject.
 */
class Callback_IIFServer_ClearNonSiderealObject_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearNonSiderealObject_Base> Callback_IIFServer_ClearNonSiderealObjectPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealObject.
 */
class Callback_IIFServer_UpdateNonSiderealObject_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_UpdateNonSiderealObject_Base> Callback_IIFServer_UpdateNonSiderealObjectPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetTelescope.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetTelescope.
 */
class Callback_IIFServer_PresetTelescope_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_PresetTelescope_Base> Callback_IIFServer_PresetTelescopePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_BinocularControl.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_BinocularControl.
 */
class Callback_IIFServer_BinocularControl_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_BinocularControl_Base> Callback_IIFServer_BinocularControlPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetParameter.
 */
class Callback_IIFServer_GetParameter_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetParameter_Base> Callback_IIFServer_GetParameterPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetParameter.
 */
class Callback_IIFServer_SetParameter_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetParameter_Base> Callback_IIFServer_SetParameterPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateCommon.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateCommon.
 */
class Callback_IIFServer_RotateCommon_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotateCommon_Base> Callback_IIFServer_RotateCommonPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateZ.
 */
class Callback_IIFServer_RotateZ_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotateZ_Base> Callback_IIFServer_RotateZPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotatePrimary.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotatePrimary.
 */
class Callback_IIFServer_RotatePrimary_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotatePrimary_Base> Callback_IIFServer_RotatePrimaryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SendWavefront.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SendWavefront.
 */
class Callback_IIFServer_SendWavefront_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SendWavefront_Base> Callback_IIFServer_SendWavefrontPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateTargetWavelength.
 */
class Callback_IIFServer_UpdateTargetWavelength_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_UpdateTargetWavelength_Base> Callback_IIFServer_UpdateTargetWavelengthPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_LogEvent.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_LogEvent.
 */
class Callback_IIFServer_LogEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_LogEvent_Base> Callback_IIFServer_LogEventPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorTrajectory.
 */
class Callback_IIFServer_GetRotatorTrajectory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetRotatorTrajectory_Base> Callback_IIFServer_GetRotatorTrajectoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorPolynomials.
 */
class Callback_IIFServer_GetRotatorPolynomials_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetRotatorPolynomials_Base> Callback_IIFServer_GetRotatorPolynomialsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_Standby.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Standby.
 */
class Callback_IIFServer_Standby_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_Standby_Base> Callback_IIFServer_StandbyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MaximizeWrapTime.
 */
class Callback_IIFServer_MaximizeWrapTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_MaximizeWrapTime_Base> Callback_IIFServer_MaximizeWrapTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseGuiding.
 */
class Callback_IIFServer_PauseGuiding_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_PauseGuiding_Base> Callback_IIFServer_PauseGuidingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeGuiding.
 */
class Callback_IIFServer_ResumeGuiding_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ResumeGuiding_Base> Callback_IIFServer_ResumeGuidingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_StopGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopGuiding.
 */
class Callback_IIFServer_StopGuiding_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_StopGuiding_Base> Callback_IIFServer_StopGuidingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingHotspot.
 */
class Callback_IIFServer_SetGuidingHotspot_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetGuidingHotspot_Base> Callback_IIFServer_SetGuidingHotspotPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetAGWFilter.
 */
class Callback_IIFServer_SetAGWFilter_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetAGWFilter_Base> Callback_IIFServer_SetAGWFilterPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingBinning.
 */
class Callback_IIFServer_SetGuidingBinning_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetGuidingBinning_Base> Callback_IIFServer_SetGuidingBinningPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotReady.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotReady.
 */
class Callback_IIFServer_RotReady_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotReady_Base> Callback_IIFServer_RotReadyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotHold.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotHold.
 */
class Callback_IIFServer_RotHold_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotHold_Base> Callback_IIFServer_RotHoldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotTrack.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotTrack.
 */
class Callback_IIFServer_RotTrack_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotTrack_Base> Callback_IIFServer_RotTrackPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RotServicePosition.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotServicePosition.
 */
class Callback_IIFServer_RotServicePosition_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RotServicePosition_Base> Callback_IIFServer_RotServicePositionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseAO.
 */
class Callback_IIFServer_PauseAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_PauseAO_Base> Callback_IIFServer_PauseAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeAO.
 */
class Callback_IIFServer_ResumeAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ResumeAO_Base> Callback_IIFServer_ResumeAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_StartAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StartAO.
 */
class Callback_IIFServer_StartAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_StartAO_Base> Callback_IIFServer_StartAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_StopAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopAO.
 */
class Callback_IIFServer_StopAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_StopAO_Base> Callback_IIFServer_StopAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_AcquireRefAO.
 */
class Callback_IIFServer_AcquireRefAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_AcquireRefAO_Base> Callback_IIFServer_AcquireRefAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_CheckRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CheckRefAO.
 */
class Callback_IIFServer_CheckRefAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_CheckRefAO_Base> Callback_IIFServer_CheckRefAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RefineAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RefineAO.
 */
class Callback_IIFServer_RefineAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RefineAO_Base> Callback_IIFServer_RefineAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_RunAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RunAO.
 */
class Callback_IIFServer_RunAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_RunAO_Base> Callback_IIFServer_RunAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetFlatAO.
 */
class Callback_IIFServer_PresetFlatAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_PresetFlatAO_Base> Callback_IIFServer_PresetFlatAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CorrectModesAO.
 */
class Callback_IIFServer_CorrectModesAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_CorrectModesAO_Base> Callback_IIFServer_CorrectModesAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ModifyAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ModifyAO.
 */
class Callback_IIFServer_ModifyAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ModifyAO_Base> Callback_IIFServer_ModifyAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetAO.
 */
class Callback_IIFServer_PresetAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_PresetAO_Base> Callback_IIFServer_PresetAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetXYAO.
 */
class Callback_IIFServer_OffsetXYAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_OffsetXYAO_Base> Callback_IIFServer_OffsetXYAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetZAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetZAO.
 */
class Callback_IIFServer_OffsetZAO_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_OffsetZAO_Base> Callback_IIFServer_OffsetZAOPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference.
 */
class Callback_IIFServer_SetReference_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetReference_Base> Callback_IIFServer_SetReferencePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReferenceNew.
 */
class Callback_IIFServer_SetReferenceNew_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetReferenceNew_Base> Callback_IIFServer_SetReferenceNewPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference2.
 */
class Callback_IIFServer_SetReference2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_SetReference2_Base> Callback_IIFServer_SetReference2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearReference.
 */
class Callback_IIFServer_ClearReference_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_ClearReference_Base> Callback_IIFServer_ClearReferencePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates.
 */
class Callback_IIFServer_GetKFPCoordinates_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetKFPCoordinates_Base> Callback_IIFServer_GetKFPCoordinatesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinatesNew.
 */
class Callback_IIFServer_GetKFPCoordinatesNew_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetKFPCoordinatesNew_Base> Callback_IIFServer_GetKFPCoordinatesNewPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates2.
 */
class Callback_IIFServer_GetKFPCoordinates2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_GetKFPCoordinates2_Base> Callback_IIFServer_GetKFPCoordinates2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_NSQuery.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_NSQuery.
 */
class Callback_IIFServer_NSQuery_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_NSQuery_Base> Callback_IIFServer_NSQueryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::lbto::IIFServer::begin_remove.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_remove.
 */
class Callback_IIFServer_remove_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_IIFServer_remove_Base> Callback_IIFServer_removePtr;

}

namespace IceProxy
{

namespace lbto
{

class IIFServer : public virtual ::Ice::Proxy<IIFServer, ::IceProxy::Ice::Object>
{
public:

    ::lbto::result ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ApplyWaffleAO(_iceI_begin_ApplyWaffleAO(modes, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ApplyWaffleAO(modes, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ApplyWaffleAO(modes, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ApplyWaffleAO(modes, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::lbto::Callback_IIFServer_ApplyWaffleAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ApplyWaffleAO(modes, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ApplyWaffleAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ApplyWaffleAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ApplyWaffleAO(modes, side, context, cb, cookie);
    }

    ::lbto::result end_ApplyWaffleAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ApplyWaffleAO(const ::lbto::SeqModes&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result Authorize(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Authorize(_iceI_begin_Authorize(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Authorize(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Authorize(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Authorize(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authorize(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authorize(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authorize(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authorize(const ::lbto::Callback_IIFServer_AuthorizePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authorize(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authorize(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_AuthorizePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authorize(context, cb, cookie);
    }

    ::lbto::result end_Authorize(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Authorize(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_StepFocus(_iceI_begin_StepFocus(relPos, ope, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StepFocus(relPos, ope, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StepFocus(relPos, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StepFocus(relPos, ope, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::lbto::Callback_IIFServer_StepFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StepFocus(relPos, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_StepFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StepFocus(relPos, ope, side, context, cb, cookie);
    }

    ::lbto::result end_StepFocus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StepFocus(::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_MoveFocus(_iceI_begin_MoveFocus(absPos, ope, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_MoveFocus(absPos, ope, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveFocus(absPos, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveFocus(absPos, ope, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::lbto::Callback_IIFServer_MoveFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveFocus(absPos, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_MoveFocusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveFocus(absPos, ope, side, context, cb, cookie);
    }

    ::lbto::result end_MoveFocus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_MoveFocus(::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_OffsetPointing(_iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::lbto::Callback_IIFServer_OffsetPointingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_OffsetPointingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing(rotangle, offx, offy, coordsys, ope, np, movetype, side, context, cb, cookie);
    }

    ::lbto::result end_OffsetPointing(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OffsetPointing(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_OffsetPointing2(_iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::lbto::Callback_IIFServer_OffsetPointing2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_OffsetPointing2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetPointing2(rotangle, offx, offy, coordsys, movetype, side, context, cb, cookie);
    }

    ::lbto::result end_OffsetPointing2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OffsetPointing2(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_OffsetGuiding(_iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::lbto::Callback_IIFServer_OffsetGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_OffsetGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetGuiding(rotangle, offx, offy, coordsys, side, context, cb, cookie);
    }

    ::lbto::result end_OffsetGuiding(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OffsetGuiding(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_UpdatePointingReference(_iceI_begin_UpdatePointingReference(offsetcoord, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdatePointingReference(offsetcoord, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdatePointingReference(offsetcoord, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdatePointingReference(offsetcoord, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::lbto::Callback_IIFServer_UpdatePointingReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdatePointingReference(offsetcoord, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_UpdatePointingReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdatePointingReference(offsetcoord, side, context, cb, cookie);
    }

    ::lbto::result end_UpdatePointingReference(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdatePointingReference(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_TipTilt(_iceI_begin_TipTilt(xrot, yrot, ope, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_TipTilt(xrot, yrot, ope, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TipTilt(xrot, yrot, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TipTilt(xrot, yrot, ope, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::lbto::Callback_IIFServer_TipTiltPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TipTilt(xrot, yrot, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_TipTiltPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_TipTilt(xrot, yrot, ope, side, context, cb, cookie);
    }

    ::lbto::result end_TipTilt(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_TipTilt(::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetPMTerm(_iceI_begin_SetPMTerm(name, value, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetPMTerm(name, value, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm(name, value, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm(name, value, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::lbto::Callback_IIFServer_SetPMTermPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm(name, value, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetPMTermPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm(name, value, side, context, cb, cookie);
    }

    ::lbto::result end_SetPMTerm(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetPMTerm(const ::std::string&, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetPMTerm2(_iceI_begin_SetPMTerm2(name, value, movetype, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetPMTerm2(name, value, movetype, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm2(name, value, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm2(name, value, movetype, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::lbto::Callback_IIFServer_SetPMTerm2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm2(name, value, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetPMTerm2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetPMTerm2(name, value, movetype, side, context, cb, cookie);
    }

    ::lbto::result end_SetPMTerm2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetPMTerm2(const ::std::string&, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_MoveXYZ(_iceI_begin_MoveXYZ(xmov, ymov, zmov, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_MoveXYZ(xmov, ymov, zmov, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXYZ(xmov, ymov, zmov, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXYZ(xmov, ymov, zmov, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::lbto::Callback_IIFServer_MoveXYZPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXYZ(xmov, ymov, zmov, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_MoveXYZPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXYZ(xmov, ymov, zmov, side, context, cb, cookie);
    }

    ::lbto::result end_MoveXYZ(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_MoveXYZ(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_MoveXY(_iceI_begin_MoveXY(xmov, ymov, ope, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_MoveXY(xmov, ymov, ope, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXY(xmov, ymov, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXY(xmov, ymov, ope, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::lbto::Callback_IIFServer_MoveXYPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXY(xmov, ymov, ope, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_MoveXYPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MoveXY(xmov, ymov, ope, side, context, cb, cookie);
    }

    ::lbto::result end_MoveXY(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_MoveXY(::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Move(_iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::lbto::Callback_IIFServer_MovePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_MovePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Move(x, y, z, rx, ry, rz, dflag, movetype, OPE, time, side, context, cb, cookie);
    }

    ::lbto::result end_Move(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Move(::Ice::Double, ::Ice::Double, ::Ice::Double, ::Ice::Double, ::Ice::Double, ::Ice::Double, ::Ice::Int, const ::std::string&, const ::std::string&, ::Ice::Int, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetTarget(_iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::lbto::Callback_IIFServer_SetTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetTarget(coord1, coord2, system, epoch, wavelength, context, cb, cookie);
    }

    ::lbto::result end_SetTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetTarget(::Ice::Double, ::Ice::Double, const ::std::string&, ::Ice::Double, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetStars(const ::lbto::SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetStars(_iceI_begin_SetStars(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetStars(const ::lbto::SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetStars(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetStars(const ::lbto::SeqPos& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars(const ::lbto::SeqPos& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars(const ::lbto::SeqPos& stars, const ::lbto::Callback_IIFServer_SetStarsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars(const ::lbto::SeqPos& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetStarsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars(stars, context, cb, cookie);
    }

    ::lbto::result end_SetStars(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetStars(const ::lbto::SeqPos&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetStarsNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetStarsNew(_iceI_begin_SetStarsNew(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetStarsNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetStarsNew(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetStarsNew(const ::lbto::SeqNewPos& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStarsNew(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStarsNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStarsNew(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStarsNew(const ::lbto::SeqNewPos& stars, const ::lbto::Callback_IIFServer_SetStarsNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStarsNew(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStarsNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetStarsNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStarsNew(stars, context, cb, cookie);
    }

    ::lbto::result end_SetStarsNew(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetStarsNew(const ::lbto::SeqNewPos&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetStars2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetStars2(_iceI_begin_SetStars2(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetStars2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetStars2(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetStars2(const ::lbto::SeqPos2& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars2(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars2(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars2(const ::lbto::SeqPos2& stars, const ::lbto::Callback_IIFServer_SetStars2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars2(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetStars2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetStars2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetStars2(stars, context, cb, cookie);
    }

    ::lbto::result end_SetStars2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetStars2(const ::lbto::SeqPos2&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearStars(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearStars(_iceI_begin_ClearStars(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearStars(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearStars(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearStars(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearStars(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearStars(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearStars(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearStars(const ::lbto::Callback_IIFServer_ClearStarsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearStars(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearStars(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearStarsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearStars(context, cb, cookie);
    }

    ::lbto::result end_ClearStars(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearStars(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetHotspot(_iceI_begin_SetHotspot(coord1, coord2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetHotspot(coord1, coord2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetHotspot(coord1, coord2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetHotspot(coord1, coord2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::lbto::Callback_IIFServer_SetHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetHotspot(coord1, coord2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetHotspot(coord1, coord2, context, cb, cookie);
    }

    ::lbto::result end_SetHotspot(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetHotspot(::Ice::Double, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearHotspot(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearHotspot(_iceI_begin_ClearHotspot(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearHotspot(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearHotspot(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearHotspot(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearHotspot(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearHotspot(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearHotspot(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearHotspot(const ::lbto::Callback_IIFServer_ClearHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearHotspot(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearHotspot(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearHotspot(context, cb, cookie);
    }

    ::lbto::result end_ClearHotspot(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearHotspot(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetOffset(_iceI_begin_SetOffset(coord1, coord2, system, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetOffset(coord1, coord2, system, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset(coord1, coord2, system, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset(coord1, coord2, system, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::lbto::Callback_IIFServer_SetOffsetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset(coord1, coord2, system, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetOffsetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset(coord1, coord2, system, context, cb, cookie);
    }

    ::lbto::result end_SetOffset(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetOffset(::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetOffsetNew(_iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::lbto::Callback_IIFServer_SetOffsetNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetOffsetNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffsetNew(coord1, coord2, system, movetype, context, cb, cookie);
    }

    ::lbto::result end_SetOffsetNew(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetOffsetNew(::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetOffset2(_iceI_begin_SetOffset2(coord1, coord2, system, movetype, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetOffset2(coord1, coord2, system, movetype, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset2(coord1, coord2, system, movetype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset2(coord1, coord2, system, movetype, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::lbto::Callback_IIFServer_SetOffset2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset2(coord1, coord2, system, movetype, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetOffset2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetOffset2(coord1, coord2, system, movetype, context, cb, cookie);
    }

    ::lbto::result end_SetOffset2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetOffset2(::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearOffset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearOffset(_iceI_begin_ClearOffset(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearOffset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearOffset(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearOffset(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearOffset(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearOffset(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearOffset(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearOffset(const ::lbto::Callback_IIFServer_ClearOffsetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearOffset(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearOffset(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearOffsetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearOffset(context, cb, cookie);
    }

    ::lbto::result end_ClearOffset(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearOffset(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetNonSidereal(_iceI_begin_SetNonSidereal(target, override, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetNonSidereal(target, override, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSidereal(target, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSidereal(target, override, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::lbto::Callback_IIFServer_SetNonSiderealPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSidereal(target, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSidereal(const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetNonSiderealPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSidereal(target, override, context, cb, cookie);
    }

    ::lbto::result end_SetNonSidereal(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetNonSidereal(const ::lbto::nonsidereal&, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearNonSidereal(bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearNonSidereal(_iceI_begin_ClearNonSidereal(override, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearNonSidereal(bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearNonSidereal(override, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSidereal(bool override, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSidereal(override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSidereal(bool override, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSidereal(override, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSidereal(bool override, const ::lbto::Callback_IIFServer_ClearNonSiderealPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSidereal(override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSidereal(bool override, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearNonSiderealPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSidereal(override, context, cb, cookie);
    }

    ::lbto::result end_ClearNonSidereal(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearNonSidereal(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_UpdateNonSiderealTarget(_iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::lbto::Callback_IIFServer_UpdateNonSiderealTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_UpdateNonSiderealTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealTarget(RArate, DECrate, context, cb, cookie);
    }

    ::lbto::result end_UpdateNonSiderealTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateNonSiderealTarget(::Ice::Double, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetNonSiderealObject(_iceI_begin_SetNonSiderealObject(objtype, target, override, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetNonSiderealObject(objtype, target, override, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSiderealObject(objtype, target, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSiderealObject(objtype, target, override, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::lbto::Callback_IIFServer_SetNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSiderealObject(objtype, target, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetNonSiderealObject(const ::std::string& objtype, const ::lbto::nonsidereal& target, bool override, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetNonSiderealObject(objtype, target, override, context, cb, cookie);
    }

    ::lbto::result end_SetNonSiderealObject(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetNonSiderealObject(const ::std::string&, const ::lbto::nonsidereal&, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearNonSiderealObject(_iceI_begin_ClearNonSiderealObject(objtype, override, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearNonSiderealObject(objtype, override, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSiderealObject(objtype, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSiderealObject(objtype, override, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::lbto::Callback_IIFServer_ClearNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSiderealObject(objtype, override, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearNonSiderealObject(objtype, override, context, cb, cookie);
    }

    ::lbto::result end_ClearNonSiderealObject(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearNonSiderealObject(const ::std::string&, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_UpdateNonSiderealObject(_iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::lbto::Callback_IIFServer_UpdateNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_UpdateNonSiderealObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateNonSiderealObject(objtype, RArate, DECrate, context, cb, cookie);
    }

    ::lbto::result end_UpdateNonSiderealObject(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateNonSiderealObject(const ::std::string&, ::Ice::Double, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PresetTelescope(_iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::lbto::Callback_IIFServer_PresetTelescopePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_PresetTelescopePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetTelescope(rotangle, rotmode, mode, side, context, cb, cookie);
    }

    ::lbto::result end_PresetTelescope(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PresetTelescope(::Ice::Double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result BinocularControl(const ::std::string& flag, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_BinocularControl(_iceI_begin_BinocularControl(flag, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_BinocularControl(const ::std::string& flag, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_BinocularControl(flag, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_BinocularControl(const ::std::string& flag, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_BinocularControl(flag, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_BinocularControl(const ::std::string& flag, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_BinocularControl(flag, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_BinocularControl(const ::std::string& flag, const ::lbto::Callback_IIFServer_BinocularControlPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_BinocularControl(flag, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_BinocularControl(const ::std::string& flag, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_BinocularControlPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_BinocularControl(flag, context, cb, cookie);
    }

    ::lbto::result end_BinocularControl(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_BinocularControl(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetParameter(_iceI_begin_GetParameter(list, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetParameter(list, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetParameter(const ::lbto::SeqDD& list, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParameter(list, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParameter(list, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParameter(const ::lbto::SeqDD& list, const ::lbto::Callback_IIFServer_GetParameterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParameter(list, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetParameterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParameter(list, context, cb, cookie);
    }

    ::lbto::result end_GetParameter(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetParameter(const ::lbto::SeqDD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetParameter(_iceI_begin_SetParameter(list, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetParameter(list, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetParameter(const ::lbto::SeqDD& list, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParameter(list, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParameter(list, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParameter(const ::lbto::SeqDD& list, const ::lbto::Callback_IIFServer_SetParameterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParameter(list, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParameter(const ::lbto::SeqDD& list, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetParameterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParameter(list, context, cb, cookie);
    }

    ::lbto::result end_SetParameter(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetParameter(const ::lbto::SeqDD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotateCommon(_iceI_begin_RotateCommon(z, angle, direction, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotateCommon(z, angle, direction, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateCommon(z, angle, direction, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateCommon(z, angle, direction, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::lbto::Callback_IIFServer_RotateCommonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateCommon(z, angle, direction, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotateCommonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateCommon(z, angle, direction, side, context, cb, cookie);
    }

    ::lbto::result end_RotateCommon(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotateCommon(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotateZ(_iceI_begin_RotateZ(angle, movetype, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotateZ(angle, movetype, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateZ(angle, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateZ(angle, movetype, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::lbto::Callback_IIFServer_RotateZPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateZ(angle, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotateZPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotateZ(angle, movetype, side, context, cb, cookie);
    }

    ::lbto::result end_RotateZ(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotateZ(::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotatePrimary(_iceI_begin_RotatePrimary(distance, angle, direction, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotatePrimary(distance, angle, direction, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotatePrimary(distance, angle, direction, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotatePrimary(distance, angle, direction, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::lbto::Callback_IIFServer_RotatePrimaryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotatePrimary(distance, angle, direction, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotatePrimaryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotatePrimary(distance, angle, direction, side, context, cb, cookie);
    }

    ::lbto::result end_RotatePrimary(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotatePrimary(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SendWavefront(_iceI_begin_SendWavefront(wfs, OPE, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendWavefront(wfs, OPE, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendWavefront(wfs, OPE, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendWavefront(wfs, OPE, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::lbto::Callback_IIFServer_SendWavefrontPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendWavefront(wfs, OPE, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendWavefront(const ::lbto::SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SendWavefrontPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendWavefront(wfs, OPE, side, context, cb, cookie);
    }

    ::lbto::result end_SendWavefront(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendWavefront(const ::lbto::SeqWF&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_UpdateTargetWavelength(_iceI_begin_UpdateTargetWavelength(wavelength, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UpdateTargetWavelength(wavelength, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTargetWavelength(wavelength, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTargetWavelength(wavelength, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::lbto::Callback_IIFServer_UpdateTargetWavelengthPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTargetWavelength(wavelength, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_UpdateTargetWavelengthPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UpdateTargetWavelength(wavelength, side, context, cb, cookie);
    }

    ::lbto::result end_UpdateTargetWavelength(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UpdateTargetWavelength(::Ice::Float, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_LogEvent(_iceI_begin_LogEvent(event, description, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LogEvent(event, description, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogEvent(event, description, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogEvent(event, description, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogEvent(const ::std::string& event, const ::std::string& description, const ::lbto::Callback_IIFServer_LogEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogEvent(event, description, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_LogEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogEvent(event, description, context, cb, cookie);
    }

    ::lbto::result end_LogEvent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LogEvent(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetRotatorTrajectory(_iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::lbto::Callback_IIFServer_GetRotatorTrajectoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetRotatorTrajectoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorTrajectory(seconds, interval, start, side, context, cb, cookie);
    }

    ::lbto::result end_GetRotatorTrajectory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetRotatorTrajectory(::Ice::Double, ::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetRotatorPolynomials(_iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::lbto::Callback_IIFServer_GetRotatorPolynomialsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetRotatorPolynomialsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRotatorPolynomials(start, count, interval, order, side, context, cb, cookie);
    }

    ::lbto::result end_GetRotatorPolynomials(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetRotatorPolynomials(::Ice::Double, ::Ice::Int, ::Ice::Double, ::Ice::Int, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result Standby(::Ice::Int level, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Standby(_iceI_begin_Standby(level, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Standby(::Ice::Int level, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Standby(level, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Standby(::Ice::Int level, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Standby(level, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Standby(::Ice::Int level, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Standby(level, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Standby(::Ice::Int level, const ::std::string& side, const ::lbto::Callback_IIFServer_StandbyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Standby(level, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Standby(::Ice::Int level, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_StandbyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Standby(level, side, context, cb, cookie);
    }

    ::lbto::result end_Standby(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Standby(::Ice::Int, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_MaximizeWrapTime(_iceI_begin_MaximizeWrapTime(azflag, rotflag, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_MaximizeWrapTime(azflag, rotflag, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MaximizeWrapTime(azflag, rotflag, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MaximizeWrapTime(azflag, rotflag, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::lbto::Callback_IIFServer_MaximizeWrapTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MaximizeWrapTime(azflag, rotflag, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_MaximizeWrapTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MaximizeWrapTime(azflag, rotflag, side, context, cb, cookie);
    }

    ::lbto::result end_MaximizeWrapTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_MaximizeWrapTime(bool, bool, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result PauseGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PauseGuiding(_iceI_begin_PauseGuiding(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PauseGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PauseGuiding(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PauseGuiding(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseGuiding(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseGuiding(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseGuiding(const ::std::string& side, const ::lbto::Callback_IIFServer_PauseGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseGuiding(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_PauseGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseGuiding(side, context, cb, cookie);
    }

    ::lbto::result end_PauseGuiding(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PauseGuiding(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ResumeGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ResumeGuiding(_iceI_begin_ResumeGuiding(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ResumeGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ResumeGuiding(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ResumeGuiding(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeGuiding(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeGuiding(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeGuiding(const ::std::string& side, const ::lbto::Callback_IIFServer_ResumeGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeGuiding(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ResumeGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeGuiding(side, context, cb, cookie);
    }

    ::lbto::result end_ResumeGuiding(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ResumeGuiding(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result StopGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_StopGuiding(_iceI_begin_StopGuiding(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StopGuiding(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StopGuiding(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopGuiding(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopGuiding(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopGuiding(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopGuiding(const ::std::string& side, const ::lbto::Callback_IIFServer_StopGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopGuiding(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopGuiding(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_StopGuidingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopGuiding(side, context, cb, cookie);
    }

    ::lbto::result end_StopGuiding(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StopGuiding(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetGuidingHotspot(_iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::lbto::Callback_IIFServer_SetGuidingHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetGuidingHotspotPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingHotspot(coord1, coord2, movetype, side, context, cb, cookie);
    }

    ::lbto::result end_SetGuidingHotspot(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetGuidingHotspot(::Ice::Double, ::Ice::Double, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetAGWFilter(_iceI_begin_SetAGWFilter(filterNumber, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetAGWFilter(filterNumber, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetAGWFilter(filterNumber, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetAGWFilter(filterNumber, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::lbto::Callback_IIFServer_SetAGWFilterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetAGWFilter(filterNumber, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetAGWFilterPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetAGWFilter(filterNumber, side, context, cb, cookie);
    }

    ::lbto::result end_SetAGWFilter(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetAGWFilter(::Ice::Int, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetGuidingBinning(_iceI_begin_SetGuidingBinning(factor, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetGuidingBinning(factor, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingBinning(factor, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingBinning(factor, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::lbto::Callback_IIFServer_SetGuidingBinningPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingBinning(factor, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetGuidingBinningPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetGuidingBinning(factor, side, context, cb, cookie);
    }

    ::lbto::result end_SetGuidingBinning(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetGuidingBinning(::Ice::Int, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotReady(bool enable, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotReady(_iceI_begin_RotReady(enable, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotReady(bool enable, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotReady(enable, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotReady(bool enable, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotReady(enable, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotReady(bool enable, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotReady(enable, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotReady(bool enable, const ::std::string& side, const ::lbto::Callback_IIFServer_RotReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotReady(enable, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotReady(bool enable, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotReadyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotReady(enable, side, context, cb, cookie);
    }

    ::lbto::result end_RotReady(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotReady(bool, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotHold(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotHold(_iceI_begin_RotHold(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotHold(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotHold(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotHold(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotHold(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotHold(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotHold(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotHold(const ::std::string& side, const ::lbto::Callback_IIFServer_RotHoldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotHold(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotHold(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotHoldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotHold(side, context, cb, cookie);
    }

    ::lbto::result end_RotHold(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotHold(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotTrack(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotTrack(_iceI_begin_RotTrack(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotTrack(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotTrack(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotTrack(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotTrack(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotTrack(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotTrack(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotTrack(const ::std::string& side, const ::lbto::Callback_IIFServer_RotTrackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotTrack(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotTrack(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotTrackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotTrack(side, context, cb, cookie);
    }

    ::lbto::result end_RotTrack(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotTrack(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RotServicePosition(_iceI_begin_RotServicePosition(angle, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RotServicePosition(angle, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotServicePosition(angle, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotServicePosition(angle, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::lbto::Callback_IIFServer_RotServicePositionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotServicePosition(angle, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RotServicePositionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RotServicePosition(angle, side, context, cb, cookie);
    }

    ::lbto::result end_RotServicePosition(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RotServicePosition(::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result PauseAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PauseAO(_iceI_begin_PauseAO(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PauseAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PauseAO(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PauseAO(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseAO(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseAO(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseAO(const ::std::string& side, const ::lbto::Callback_IIFServer_PauseAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseAO(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_PauseAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseAO(side, context, cb, cookie);
    }

    ::lbto::result end_PauseAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PauseAO(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ResumeAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ResumeAO(_iceI_begin_ResumeAO(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ResumeAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ResumeAO(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ResumeAO(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeAO(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeAO(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeAO(const ::std::string& side, const ::lbto::Callback_IIFServer_ResumeAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeAO(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ResumeAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeAO(side, context, cb, cookie);
    }

    ::lbto::result end_ResumeAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ResumeAO(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result StartAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_StartAO(_iceI_begin_StartAO(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartAO(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartAO(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartAO(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartAO(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartAO(const ::std::string& side, const ::lbto::Callback_IIFServer_StartAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartAO(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_StartAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartAO(side, context, cb, cookie);
    }

    ::lbto::result end_StartAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartAO(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_StopAO(_iceI_begin_StopAO(reason, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StopAO(reason, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopAO(reason, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopAO(reason, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopAO(const ::std::string& reason, const ::std::string& side, const ::lbto::Callback_IIFServer_StopAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopAO(reason, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_StopAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopAO(reason, side, context, cb, cookie);
    }

    ::lbto::result end_StopAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StopAO(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_AcquireRefAO(_iceI_begin_AcquireRefAO(repointFlag, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_AcquireRefAO(repointFlag, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AcquireRefAO(repointFlag, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AcquireRefAO(repointFlag, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AcquireRefAO(bool repointFlag, const ::std::string& side, const ::lbto::Callback_IIFServer_AcquireRefAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AcquireRefAO(repointFlag, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_AcquireRefAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AcquireRefAO(repointFlag, side, context, cb, cookie);
    }

    ::lbto::result end_AcquireRefAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_AcquireRefAO(bool, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result CheckRefAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_CheckRefAO(_iceI_begin_CheckRefAO(side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_CheckRefAO(const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_CheckRefAO(side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CheckRefAO(const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckRefAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckRefAO(const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckRefAO(side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckRefAO(const ::std::string& side, const ::lbto::Callback_IIFServer_CheckRefAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckRefAO(side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CheckRefAO(const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_CheckRefAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CheckRefAO(side, context, cb, cookie);
    }

    ::lbto::result end_CheckRefAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_CheckRefAO(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RefineAO(_iceI_begin_RefineAO(method, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RefineAO(method, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RefineAO(method, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RefineAO(method, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RefineAO(const ::std::string& method, const ::std::string& side, const ::lbto::Callback_IIFServer_RefineAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RefineAO(method, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RefineAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RefineAO(method, side, context, cb, cookie);
    }

    ::lbto::result end_RefineAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RefineAO(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RunAO(_iceI_begin_RunAO(type, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RunAO(type, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunAO(type, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunAO(type, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunAO(const ::std::string& type, const ::std::string& side, const ::lbto::Callback_IIFServer_RunAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunAO(type, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_RunAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunAO(type, side, context, cb, cookie);
    }

    ::lbto::result end_RunAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RunAO(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PresetFlatAO(_iceI_begin_PresetFlatAO(flat, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PresetFlatAO(flat, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetFlatAO(flat, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetFlatAO(flat, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::lbto::Callback_IIFServer_PresetFlatAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetFlatAO(flat, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_PresetFlatAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetFlatAO(flat, side, context, cb, cookie);
    }

    ::lbto::result end_PresetFlatAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PresetFlatAO(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_CorrectModesAO(_iceI_begin_CorrectModesAO(modes, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_CorrectModesAO(modes, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CorrectModesAO(modes, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CorrectModesAO(modes, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::lbto::Callback_IIFServer_CorrectModesAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CorrectModesAO(modes, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_CorrectModesAO(const ::lbto::SeqModes& modes, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_CorrectModesAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CorrectModesAO(modes, side, context, cb, cookie);
    }

    ::lbto::result end_CorrectModesAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_CorrectModesAO(const ::lbto::SeqModes&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ModifyAO(_iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::lbto::Callback_IIFServer_ModifyAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ModifyAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ModifyAO(NModes, Freq, Nbins, TTMod, F1spec, F2spec, side, context, cb, cookie);
    }

    ::lbto::result end_ModifyAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ModifyAO(::Ice::Int, ::Ice::Double, ::Ice::Int, ::Ice::Double, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PresetAO(_iceI_begin_PresetAO(AOMode, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PresetAO(AOMode, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetAO(AOMode, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetAO(AOMode, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::lbto::Callback_IIFServer_PresetAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetAO(AOMode, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_PresetAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PresetAO(AOMode, side, context, cb, cookie);
    }

    ::lbto::result end_PresetAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PresetAO(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_OffsetXYAO(_iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::lbto::Callback_IIFServer_OffsetXYAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_OffsetXYAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetXYAO(DeltaX, DeltaY, side, context, cb, cookie);
    }

    ::lbto::result end_OffsetXYAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OffsetXYAO(::Ice::Double, ::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_OffsetZAO(_iceI_begin_OffsetZAO(DeltaZ, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OffsetZAO(DeltaZ, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetZAO(DeltaZ, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetZAO(DeltaZ, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::lbto::Callback_IIFServer_OffsetZAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetZAO(DeltaZ, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_OffsetZAOPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OffsetZAO(DeltaZ, side, context, cb, cookie);
    }

    ::lbto::result end_OffsetZAO(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OffsetZAO(::Ice::Double, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetReference(const ::lbto::SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetReference(_iceI_begin_SetReference(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetReference(const ::lbto::SeqPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetReference(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetReference(const ::lbto::SeqPos& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference(const ::lbto::SeqPos& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference(const ::lbto::SeqPos& stars, const ::lbto::Callback_IIFServer_SetReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference(const ::lbto::SeqPos& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference(stars, context, cb, cookie);
    }

    ::lbto::result end_SetReference(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetReference(const ::lbto::SeqPos&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetReferenceNew(_iceI_begin_SetReferenceNew(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetReferenceNew(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReferenceNew(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReferenceNew(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::lbto::Callback_IIFServer_SetReferenceNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReferenceNew(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReferenceNew(const ::lbto::SeqNewPos& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetReferenceNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReferenceNew(stars, context, cb, cookie);
    }

    ::lbto::result end_SetReferenceNew(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetReferenceNew(const ::lbto::SeqNewPos&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result SetReference2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetReference2(_iceI_begin_SetReference2(stars, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetReference2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetReference2(stars, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetReference2(const ::lbto::SeqPos2& stars, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference2(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference2(stars, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference2(const ::lbto::SeqPos2& stars, const ::lbto::Callback_IIFServer_SetReference2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference2(stars, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetReference2(const ::lbto::SeqPos2& stars, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_SetReference2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetReference2(stars, context, cb, cookie);
    }

    ::lbto::result end_SetReference2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetReference2(const ::lbto::SeqPos2&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result ClearReference(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ClearReference(_iceI_begin_ClearReference(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearReference(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearReference(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearReference(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearReference(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearReference(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearReference(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearReference(const ::lbto::Callback_IIFServer_ClearReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearReference(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearReference(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_ClearReferencePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearReference(context, cb, cookie);
    }

    ::lbto::result end_ClearReference(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearReference(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetKFPCoordinates(_iceI_begin_GetKFPCoordinates(stars, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKFPCoordinates(stars, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates(stars, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::lbto::Callback_IIFServer_GetKFPCoordinatesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates(const ::lbto::SeqPos& stars, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetKFPCoordinatesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates(stars, side, context, cb, cookie);
    }

    ::lbto::result end_GetKFPCoordinates(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKFPCoordinates(const ::lbto::SeqPos&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetKFPCoordinatesNew(_iceI_begin_GetKFPCoordinatesNew(stars, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKFPCoordinatesNew(stars, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinatesNew(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinatesNew(stars, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::lbto::Callback_IIFServer_GetKFPCoordinatesNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinatesNew(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos& stars, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetKFPCoordinatesNewPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinatesNew(stars, side, context, cb, cookie);
    }

    ::lbto::result end_GetKFPCoordinatesNew(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKFPCoordinatesNew(const ::lbto::SeqNewPos&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetKFPCoordinates2(_iceI_begin_GetKFPCoordinates2(stars, side, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetKFPCoordinates2(stars, side, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates2(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates2(stars, side, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::lbto::Callback_IIFServer_GetKFPCoordinates2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates2(stars, side, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetKFPCoordinates2(const ::lbto::SeqPos2& stars, const ::std::string& side, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_GetKFPCoordinates2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetKFPCoordinates2(stars, side, context, cb, cookie);
    }

    ::lbto::result end_GetKFPCoordinates2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetKFPCoordinates2(const ::lbto::SeqPos2&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::lbto::result NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_NSQuery(_iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::lbto::Callback_IIFServer_NSQueryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Context& context, const ::lbto::Callback_IIFServer_NSQueryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_NSQuery(targenName, startDate, startTime, endDate, endTime, interval, fileName, context, cb, cookie);
    }

    ::lbto::result end_NSQuery(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_NSQuery(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void remove(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_remove(_iceI_begin_remove(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_remove(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_remove(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_remove(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::lbto::Callback_IIFServer_removePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_remove(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& context, const ::lbto::Callback_IIFServer_removePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_remove(context, cb, cookie);
    }

    void end_remove(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_remove(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace lbto
{

/**
 * @brief methods implemented
 */
class IIFServer : public virtual ::Ice::Object
{
public:

    typedef IIFServerPrx ProxyType;
    typedef IIFServerPtr PointerType;

    virtual ~IIFServer();

#ifdef ICE_CPP11_COMPILER
    IIFServer() = default;
    IIFServer(const IIFServer&) = default;
    IIFServer& operator=(const IIFServer&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual result ApplyWaffleAO(const SeqModes& modes, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ApplyWaffleAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Authorize(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Authorize(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StepFocus(::Ice::Double relPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StepFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveFocus(::Ice::Double absPos, const ::std::string& ope, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveFocus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetPointing(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& ope, const ::std::string& np, const ::std::string& movetype, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetPointing(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetPointing2(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& movetype, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetPointing2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetGuiding(::Ice::Double rotangle, ::Ice::Double offx, ::Ice::Double offy, const ::std::string& coordsys, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdatePointingReference(const ::std::string& offsetcoord, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdatePointingReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result TipTilt(::Ice::Double xrot, ::Ice::Double yrot, const ::std::string& ope, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_TipTilt(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetPMTerm(const ::std::string& name, ::Ice::Double value, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetPMTerm(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetPMTerm2(const ::std::string& name, ::Ice::Double value, const ::std::string& movetype, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetPMTerm2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveXYZ(::Ice::Double xmov, ::Ice::Double ymov, ::Ice::Double zmov, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveXYZ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MoveXY(::Ice::Double xmov, ::Ice::Double ymov, const ::std::string& ope, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_MoveXY(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Move(::Ice::Double x, ::Ice::Double y, ::Ice::Double z, ::Ice::Double rx, ::Ice::Double ry, ::Ice::Double rz, ::Ice::Int dflag, const ::std::string& movetype, const ::std::string& OPE, ::Ice::Int time, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Move(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetTarget(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, ::Ice::Double epoch, ::Ice::Float wavelength, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStars(const SeqPos& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStars(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStarsNew(const SeqNewPos& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStarsNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetStars2(const SeqPos2& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetStars2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearStars(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearStars(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearHotspot(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffset(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffsetNew(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffsetNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetOffset2(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& system, const ::std::string& movetype, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetOffset2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearOffset(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearOffset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetNonSidereal(const nonsidereal& target, bool override, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetNonSidereal(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearNonSidereal(bool override, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearNonSidereal(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateNonSiderealTarget(::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateNonSiderealTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetNonSiderealObject(const ::std::string& objtype, const nonsidereal& target, bool override, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearNonSiderealObject(const ::std::string& objtype, bool override, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateNonSiderealObject(const ::std::string& objtype, ::Ice::Double RArate, ::Ice::Double DECrate, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateNonSiderealObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetTelescope(::Ice::Double rotangle, const ::std::string& rotmode, const ::std::string& mode, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetTelescope(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result BinocularControl(const ::std::string& flag, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_BinocularControl(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetParameter(const SeqDD& list, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParameter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetParameter(const SeqDD& list, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetParameter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotateCommon(::Ice::Double z, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotateCommon(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotateZ(::Ice::Double angle, const ::std::string& movetype, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotateZ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotatePrimary(::Ice::Double distance, ::Ice::Double angle, ::Ice::Double direction, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotatePrimary(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SendWavefront(const SeqWF& wfs, const ::std::string& OPE, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendWavefront(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result UpdateTargetWavelength(::Ice::Float wavelength, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UpdateTargetWavelength(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result LogEvent(const ::std::string& event, const ::std::string& description, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_LogEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetRotatorTrajectory(::Ice::Double seconds, ::Ice::Double interval, ::Ice::Double start, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRotatorTrajectory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetRotatorPolynomials(::Ice::Double start, ::Ice::Int count, ::Ice::Double interval, ::Ice::Int order, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRotatorPolynomials(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result Standby(::Ice::Int level, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Standby(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result MaximizeWrapTime(bool azflag, bool rotflag, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_MaximizeWrapTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PauseGuiding(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ResumeGuiding(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StopGuiding(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StopGuiding(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetGuidingHotspot(::Ice::Double coord1, ::Ice::Double coord2, const ::std::string& movetype, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetGuidingHotspot(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetAGWFilter(::Ice::Int filterNumber, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetAGWFilter(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetGuidingBinning(::Ice::Int factor, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetGuidingBinning(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotReady(bool enable, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotReady(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotHold(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotHold(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotTrack(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotTrack(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RotServicePosition(::Ice::Double angle, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RotServicePosition(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PauseAO(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ResumeAO(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StartAO(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result StopAO(const ::std::string& reason, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StopAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result AcquireRefAO(bool repointFlag, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_AcquireRefAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result CheckRefAO(const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_CheckRefAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RefineAO(const ::std::string& method, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RefineAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result RunAO(const ::std::string& type, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RunAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetFlatAO(const ::std::string& flat, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetFlatAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result CorrectModesAO(const SeqModes& modes, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_CorrectModesAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ModifyAO(::Ice::Int NModes, ::Ice::Double Freq, ::Ice::Int Nbins, ::Ice::Double TTMod, const ::std::string& F1spec, const ::std::string& F2spec, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ModifyAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result PresetAO(const ::std::string& AOMode, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PresetAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetXYAO(::Ice::Double DeltaX, ::Ice::Double DeltaY, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetXYAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result OffsetZAO(::Ice::Double DeltaZ, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OffsetZAO(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReference(const SeqPos& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReferenceNew(const SeqNewPos& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReferenceNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result SetReference2(const SeqPos2& stars, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetReference2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result ClearReference(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearReference(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinates(const SeqPos& stars, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinates(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinatesNew(const SeqNewPos& stars, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinatesNew(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result GetKFPCoordinates2(const SeqPos2& stars, const ::std::string& side, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetKFPCoordinates2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual result NSQuery(const ::std::string& targenName, const ::std::string& startDate, const ::std::string& startTime, const ::std::string& endDate, const ::std::string& endTime, const ::std::string& interval, const ::std::string& fileName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_NSQuery(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void remove(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_remove(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const IIFServer& lhs, const IIFServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const IIFServer& lhs, const IIFServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::lbto::DDstruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::DDstruct, S>
{
    static void write(S* ostr, const ::lbto::DDstruct& v)
    {
        ostr->write(v.DDname);
        ostr->write(v.DDkey);
        ostr->write(v.dataType);
        ostr->write(v.comment);
    }
};

template<typename S>
struct StreamReader< ::lbto::DDstruct, S>
{
    static void read(S* istr, ::lbto::DDstruct& v)
    {
        istr->read(v.DDname);
        istr->read(v.DDkey);
        istr->read(v.dataType);
        istr->read(v.comment);
    }
};

template<>
struct StreamableTraits< ::lbto::position>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 65;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::position, S>
{
    static void write(S* ostr, const ::lbto::position& v)
    {
        ostr->write(v.coord1);
        ostr->write(v.coord2);
        ostr->write(v.system);
        ostr->write(v.epoch);
        ostr->write(v.equinox);
        ostr->write(v.pmcoord1);
        ostr->write(v.pmcoord2);
        ostr->write(v.apparentMagnitude);
        ostr->write(v.filter);
        ostr->write(v.color);
        ostr->write(v.colorType);
        ostr->write(v.wavelength);
        ostr->write(v.targname);
    }
};

template<typename S>
struct StreamReader< ::lbto::position, S>
{
    static void read(S* istr, ::lbto::position& v)
    {
        istr->read(v.coord1);
        istr->read(v.coord2);
        istr->read(v.system);
        istr->read(v.epoch);
        istr->read(v.equinox);
        istr->read(v.pmcoord1);
        istr->read(v.pmcoord2);
        istr->read(v.apparentMagnitude);
        istr->read(v.filter);
        istr->read(v.color);
        istr->read(v.colorType);
        istr->read(v.wavelength);
        istr->read(v.targname);
    }
};

template<>
struct StreamableTraits< ::lbto::newposition>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 90;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::newposition, S>
{
    static void write(S* ostr, const ::lbto::newposition& v)
    {
        ostr->write(v.type);
        ostr->write(v.coord1);
        ostr->write(v.coord2);
        ostr->write(v.system);
        ostr->write(v.equinox);
        ostr->write(v.epoch);
        ostr->write(v.pmcoord1);
        ostr->write(v.pmcoord2);
        ostr->write(v.apparentMagnitude);
        ostr->write(v.filter);
        ostr->write(v.color);
        ostr->write(v.colorType);
        ostr->write(v.wavelength);
        ostr->write(v.file);
        ostr->write(v.time);
        ostr->write(v.RARate);
        ostr->write(v.DECRate);
    }
};

template<typename S>
struct StreamReader< ::lbto::newposition, S>
{
    static void read(S* istr, ::lbto::newposition& v)
    {
        istr->read(v.type);
        istr->read(v.coord1);
        istr->read(v.coord2);
        istr->read(v.system);
        istr->read(v.equinox);
        istr->read(v.epoch);
        istr->read(v.pmcoord1);
        istr->read(v.pmcoord2);
        istr->read(v.apparentMagnitude);
        istr->read(v.filter);
        istr->read(v.color);
        istr->read(v.colorType);
        istr->read(v.wavelength);
        istr->read(v.file);
        istr->read(v.time);
        istr->read(v.RARate);
        istr->read(v.DECRate);
    }
};

template<>
struct StreamableTraits< ::lbto::position2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 90;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::position2, S>
{
    static void write(S* ostr, const ::lbto::position2& v)
    {
        ostr->write(v.type);
        ostr->write(v.coord1);
        ostr->write(v.coord2);
        ostr->write(v.system);
        ostr->write(v.epoch);
        ostr->write(v.equinox);
        ostr->write(v.pmcoord1);
        ostr->write(v.pmcoord2);
        ostr->write(v.apparentMagnitude);
        ostr->write(v.filter);
        ostr->write(v.color);
        ostr->write(v.colorType);
        ostr->write(v.wavelength);
        ostr->write(v.file);
        ostr->write(v.time);
        ostr->write(v.RARate);
        ostr->write(v.DECRate);
    }
};

template<typename S>
struct StreamReader< ::lbto::position2, S>
{
    static void read(S* istr, ::lbto::position2& v)
    {
        istr->read(v.type);
        istr->read(v.coord1);
        istr->read(v.coord2);
        istr->read(v.system);
        istr->read(v.epoch);
        istr->read(v.equinox);
        istr->read(v.pmcoord1);
        istr->read(v.pmcoord2);
        istr->read(v.apparentMagnitude);
        istr->read(v.filter);
        istr->read(v.color);
        istr->read(v.colorType);
        istr->read(v.wavelength);
        istr->read(v.file);
        istr->read(v.time);
        istr->read(v.RARate);
        istr->read(v.DECRate);
    }
};

template<>
struct StreamableTraits< ::lbto::nonsidereal>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 46;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::nonsidereal, S>
{
    static void write(S* ostr, const ::lbto::nonsidereal& v)
    {
        ostr->write(v.type);
        ostr->write(v.wavelength);
        ostr->write(v.file);
        ostr->write(v.value0);
        ostr->write(v.value1);
        ostr->write(v.value2);
        ostr->write(v.value3);
        ostr->write(v.value4);
    }
};

template<typename S>
struct StreamReader< ::lbto::nonsidereal, S>
{
    static void read(S* istr, ::lbto::nonsidereal& v)
    {
        istr->read(v.type);
        istr->read(v.wavelength);
        istr->read(v.file);
        istr->read(v.value0);
        istr->read(v.value1);
        istr->read(v.value2);
        istr->read(v.value3);
        istr->read(v.value4);
    }
};

template<>
struct StreamableTraits< ::lbto::result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::lbto::result, S>
{
    static void write(S* ostr, const ::lbto::result& v)
    {
        ostr->write(v.rescode);
        ostr->write(v.resmsg);
    }
};

template<typename S>
struct StreamReader< ::lbto::result, S>
{
    static void read(S* istr, ::lbto::result& v)
    {
        istr->read(v.rescode);
        istr->read(v.resmsg);
    }
};

}
/// \endcond

namespace lbto
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ApplyWaffleAO.
 */
template<class T>
class CallbackNC_IIFServer_ApplyWaffleAO : public Callback_IIFServer_ApplyWaffleAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ApplyWaffleAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ApplyWaffleAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 */
template<class T> Callback_IIFServer_ApplyWaffleAOPtr
newCallback_IIFServer_ApplyWaffleAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ApplyWaffleAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 */
template<class T> Callback_IIFServer_ApplyWaffleAOPtr
newCallback_IIFServer_ApplyWaffleAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ApplyWaffleAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ApplyWaffleAO.
 */
template<class T, typename CT>
class Callback_IIFServer_ApplyWaffleAO : public Callback_IIFServer_ApplyWaffleAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ApplyWaffleAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ApplyWaffleAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 */
template<class T, typename CT> Callback_IIFServer_ApplyWaffleAOPtr
newCallback_IIFServer_ApplyWaffleAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ApplyWaffleAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ApplyWaffleAO.
 */
template<class T, typename CT> Callback_IIFServer_ApplyWaffleAOPtr
newCallback_IIFServer_ApplyWaffleAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ApplyWaffleAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_Authorize.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Authorize.
 */
template<class T>
class CallbackNC_IIFServer_Authorize : public Callback_IIFServer_Authorize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_Authorize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Authorize(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Authorize.
 */
template<class T> Callback_IIFServer_AuthorizePtr
newCallback_IIFServer_Authorize(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Authorize<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Authorize.
 */
template<class T> Callback_IIFServer_AuthorizePtr
newCallback_IIFServer_Authorize(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Authorize<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_Authorize.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Authorize.
 */
template<class T, typename CT>
class Callback_IIFServer_Authorize : public Callback_IIFServer_Authorize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_Authorize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Authorize(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Authorize.
 */
template<class T, typename CT> Callback_IIFServer_AuthorizePtr
newCallback_IIFServer_Authorize(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Authorize<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Authorize.
 */
template<class T, typename CT> Callback_IIFServer_AuthorizePtr
newCallback_IIFServer_Authorize(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Authorize<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_StepFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StepFocus.
 */
template<class T>
class CallbackNC_IIFServer_StepFocus : public Callback_IIFServer_StepFocus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_StepFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StepFocus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StepFocus.
 */
template<class T> Callback_IIFServer_StepFocusPtr
newCallback_IIFServer_StepFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StepFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StepFocus.
 */
template<class T> Callback_IIFServer_StepFocusPtr
newCallback_IIFServer_StepFocus(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StepFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_StepFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StepFocus.
 */
template<class T, typename CT>
class Callback_IIFServer_StepFocus : public Callback_IIFServer_StepFocus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_StepFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StepFocus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StepFocus.
 */
template<class T, typename CT> Callback_IIFServer_StepFocusPtr
newCallback_IIFServer_StepFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StepFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StepFocus.
 */
template<class T, typename CT> Callback_IIFServer_StepFocusPtr
newCallback_IIFServer_StepFocus(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StepFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveFocus.
 */
template<class T>
class CallbackNC_IIFServer_MoveFocus : public Callback_IIFServer_MoveFocus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_MoveFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveFocus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveFocus.
 */
template<class T> Callback_IIFServer_MoveFocusPtr
newCallback_IIFServer_MoveFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveFocus.
 */
template<class T> Callback_IIFServer_MoveFocusPtr
newCallback_IIFServer_MoveFocus(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveFocus<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveFocus.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveFocus.
 */
template<class T, typename CT>
class Callback_IIFServer_MoveFocus : public Callback_IIFServer_MoveFocus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_MoveFocus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveFocus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveFocus.
 */
template<class T, typename CT> Callback_IIFServer_MoveFocusPtr
newCallback_IIFServer_MoveFocus(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveFocus.
 */
template<class T, typename CT> Callback_IIFServer_MoveFocusPtr
newCallback_IIFServer_MoveFocus(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveFocus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing.
 */
template<class T>
class CallbackNC_IIFServer_OffsetPointing : public Callback_IIFServer_OffsetPointing_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_OffsetPointing(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetPointing(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing.
 */
template<class T> Callback_IIFServer_OffsetPointingPtr
newCallback_IIFServer_OffsetPointing(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetPointing<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing.
 */
template<class T> Callback_IIFServer_OffsetPointingPtr
newCallback_IIFServer_OffsetPointing(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetPointing<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing.
 */
template<class T, typename CT>
class Callback_IIFServer_OffsetPointing : public Callback_IIFServer_OffsetPointing_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_OffsetPointing(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetPointing(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing.
 */
template<class T, typename CT> Callback_IIFServer_OffsetPointingPtr
newCallback_IIFServer_OffsetPointing(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetPointing<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing.
 */
template<class T, typename CT> Callback_IIFServer_OffsetPointingPtr
newCallback_IIFServer_OffsetPointing(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetPointing<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing2.
 */
template<class T>
class CallbackNC_IIFServer_OffsetPointing2 : public Callback_IIFServer_OffsetPointing2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_OffsetPointing2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetPointing2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 */
template<class T> Callback_IIFServer_OffsetPointing2Ptr
newCallback_IIFServer_OffsetPointing2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetPointing2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 */
template<class T> Callback_IIFServer_OffsetPointing2Ptr
newCallback_IIFServer_OffsetPointing2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetPointing2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetPointing2.
 */
template<class T, typename CT>
class Callback_IIFServer_OffsetPointing2 : public Callback_IIFServer_OffsetPointing2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_OffsetPointing2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetPointing2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 */
template<class T, typename CT> Callback_IIFServer_OffsetPointing2Ptr
newCallback_IIFServer_OffsetPointing2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetPointing2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetPointing2.
 */
template<class T, typename CT> Callback_IIFServer_OffsetPointing2Ptr
newCallback_IIFServer_OffsetPointing2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetPointing2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetGuiding.
 */
template<class T>
class CallbackNC_IIFServer_OffsetGuiding : public Callback_IIFServer_OffsetGuiding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_OffsetGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 */
template<class T> Callback_IIFServer_OffsetGuidingPtr
newCallback_IIFServer_OffsetGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 */
template<class T> Callback_IIFServer_OffsetGuidingPtr
newCallback_IIFServer_OffsetGuiding(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetGuiding.
 */
template<class T, typename CT>
class Callback_IIFServer_OffsetGuiding : public Callback_IIFServer_OffsetGuiding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_OffsetGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 */
template<class T, typename CT> Callback_IIFServer_OffsetGuidingPtr
newCallback_IIFServer_OffsetGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetGuiding.
 */
template<class T, typename CT> Callback_IIFServer_OffsetGuidingPtr
newCallback_IIFServer_OffsetGuiding(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdatePointingReference.
 */
template<class T>
class CallbackNC_IIFServer_UpdatePointingReference : public Callback_IIFServer_UpdatePointingReference_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_UpdatePointingReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdatePointingReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 */
template<class T> Callback_IIFServer_UpdatePointingReferencePtr
newCallback_IIFServer_UpdatePointingReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdatePointingReference<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 */
template<class T> Callback_IIFServer_UpdatePointingReferencePtr
newCallback_IIFServer_UpdatePointingReference(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdatePointingReference<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdatePointingReference.
 */
template<class T, typename CT>
class Callback_IIFServer_UpdatePointingReference : public Callback_IIFServer_UpdatePointingReference_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_UpdatePointingReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdatePointingReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 */
template<class T, typename CT> Callback_IIFServer_UpdatePointingReferencePtr
newCallback_IIFServer_UpdatePointingReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdatePointingReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdatePointingReference.
 */
template<class T, typename CT> Callback_IIFServer_UpdatePointingReferencePtr
newCallback_IIFServer_UpdatePointingReference(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdatePointingReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_TipTilt.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_TipTilt.
 */
template<class T>
class CallbackNC_IIFServer_TipTilt : public Callback_IIFServer_TipTilt_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_TipTilt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_TipTilt(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_TipTilt.
 */
template<class T> Callback_IIFServer_TipTiltPtr
newCallback_IIFServer_TipTilt(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_TipTilt<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_TipTilt.
 */
template<class T> Callback_IIFServer_TipTiltPtr
newCallback_IIFServer_TipTilt(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_TipTilt<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_TipTilt.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_TipTilt.
 */
template<class T, typename CT>
class Callback_IIFServer_TipTilt : public Callback_IIFServer_TipTilt_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_TipTilt(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_TipTilt(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_TipTilt.
 */
template<class T, typename CT> Callback_IIFServer_TipTiltPtr
newCallback_IIFServer_TipTilt(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_TipTilt<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_TipTilt.
 */
template<class T, typename CT> Callback_IIFServer_TipTiltPtr
newCallback_IIFServer_TipTilt(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_TipTilt<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm.
 */
template<class T>
class CallbackNC_IIFServer_SetPMTerm : public Callback_IIFServer_SetPMTerm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetPMTerm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetPMTerm(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm.
 */
template<class T> Callback_IIFServer_SetPMTermPtr
newCallback_IIFServer_SetPMTerm(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetPMTerm<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm.
 */
template<class T> Callback_IIFServer_SetPMTermPtr
newCallback_IIFServer_SetPMTerm(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetPMTerm<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm.
 */
template<class T, typename CT>
class Callback_IIFServer_SetPMTerm : public Callback_IIFServer_SetPMTerm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetPMTerm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetPMTerm(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm.
 */
template<class T, typename CT> Callback_IIFServer_SetPMTermPtr
newCallback_IIFServer_SetPMTerm(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetPMTerm<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm.
 */
template<class T, typename CT> Callback_IIFServer_SetPMTermPtr
newCallback_IIFServer_SetPMTerm(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetPMTerm<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm2.
 */
template<class T>
class CallbackNC_IIFServer_SetPMTerm2 : public Callback_IIFServer_SetPMTerm2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetPMTerm2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetPMTerm2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 */
template<class T> Callback_IIFServer_SetPMTerm2Ptr
newCallback_IIFServer_SetPMTerm2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetPMTerm2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 */
template<class T> Callback_IIFServer_SetPMTerm2Ptr
newCallback_IIFServer_SetPMTerm2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetPMTerm2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetPMTerm2.
 */
template<class T, typename CT>
class Callback_IIFServer_SetPMTerm2 : public Callback_IIFServer_SetPMTerm2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetPMTerm2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetPMTerm2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 */
template<class T, typename CT> Callback_IIFServer_SetPMTerm2Ptr
newCallback_IIFServer_SetPMTerm2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetPMTerm2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetPMTerm2.
 */
template<class T, typename CT> Callback_IIFServer_SetPMTerm2Ptr
newCallback_IIFServer_SetPMTerm2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetPMTerm2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXYZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXYZ.
 */
template<class T>
class CallbackNC_IIFServer_MoveXYZ : public Callback_IIFServer_MoveXYZ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_MoveXYZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveXYZ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXYZ.
 */
template<class T> Callback_IIFServer_MoveXYZPtr
newCallback_IIFServer_MoveXYZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveXYZ<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXYZ.
 */
template<class T> Callback_IIFServer_MoveXYZPtr
newCallback_IIFServer_MoveXYZ(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveXYZ<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXYZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXYZ.
 */
template<class T, typename CT>
class Callback_IIFServer_MoveXYZ : public Callback_IIFServer_MoveXYZ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_MoveXYZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveXYZ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXYZ.
 */
template<class T, typename CT> Callback_IIFServer_MoveXYZPtr
newCallback_IIFServer_MoveXYZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveXYZ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXYZ.
 */
template<class T, typename CT> Callback_IIFServer_MoveXYZPtr
newCallback_IIFServer_MoveXYZ(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveXYZ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXY.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXY.
 */
template<class T>
class CallbackNC_IIFServer_MoveXY : public Callback_IIFServer_MoveXY_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_MoveXY(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveXY(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXY.
 */
template<class T> Callback_IIFServer_MoveXYPtr
newCallback_IIFServer_MoveXY(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveXY<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXY.
 */
template<class T> Callback_IIFServer_MoveXYPtr
newCallback_IIFServer_MoveXY(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MoveXY<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_MoveXY.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MoveXY.
 */
template<class T, typename CT>
class Callback_IIFServer_MoveXY : public Callback_IIFServer_MoveXY_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_MoveXY(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MoveXY(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXY.
 */
template<class T, typename CT> Callback_IIFServer_MoveXYPtr
newCallback_IIFServer_MoveXY(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveXY<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MoveXY.
 */
template<class T, typename CT> Callback_IIFServer_MoveXYPtr
newCallback_IIFServer_MoveXY(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MoveXY<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_Move.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Move.
 */
template<class T>
class CallbackNC_IIFServer_Move : public Callback_IIFServer_Move_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_Move(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Move(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Move.
 */
template<class T> Callback_IIFServer_MovePtr
newCallback_IIFServer_Move(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Move<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Move.
 */
template<class T> Callback_IIFServer_MovePtr
newCallback_IIFServer_Move(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Move<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_Move.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Move.
 */
template<class T, typename CT>
class Callback_IIFServer_Move : public Callback_IIFServer_Move_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_Move(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Move(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Move.
 */
template<class T, typename CT> Callback_IIFServer_MovePtr
newCallback_IIFServer_Move(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Move<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Move.
 */
template<class T, typename CT> Callback_IIFServer_MovePtr
newCallback_IIFServer_Move(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Move<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetTarget.
 */
template<class T>
class CallbackNC_IIFServer_SetTarget : public Callback_IIFServer_SetTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetTarget.
 */
template<class T> Callback_IIFServer_SetTargetPtr
newCallback_IIFServer_SetTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetTarget.
 */
template<class T> Callback_IIFServer_SetTargetPtr
newCallback_IIFServer_SetTarget(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetTarget.
 */
template<class T, typename CT>
class Callback_IIFServer_SetTarget : public Callback_IIFServer_SetTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetTarget.
 */
template<class T, typename CT> Callback_IIFServer_SetTargetPtr
newCallback_IIFServer_SetTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetTarget.
 */
template<class T, typename CT> Callback_IIFServer_SetTargetPtr
newCallback_IIFServer_SetTarget(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars.
 */
template<class T>
class CallbackNC_IIFServer_SetStars : public Callback_IIFServer_SetStars_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetStars(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStars(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars.
 */
template<class T> Callback_IIFServer_SetStarsPtr
newCallback_IIFServer_SetStars(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStars<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars.
 */
template<class T> Callback_IIFServer_SetStarsPtr
newCallback_IIFServer_SetStars(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStars<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars.
 */
template<class T, typename CT>
class Callback_IIFServer_SetStars : public Callback_IIFServer_SetStars_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetStars(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStars(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars.
 */
template<class T, typename CT> Callback_IIFServer_SetStarsPtr
newCallback_IIFServer_SetStars(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStars<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars.
 */
template<class T, typename CT> Callback_IIFServer_SetStarsPtr
newCallback_IIFServer_SetStars(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStars<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStarsNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStarsNew.
 */
template<class T>
class CallbackNC_IIFServer_SetStarsNew : public Callback_IIFServer_SetStarsNew_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetStarsNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStarsNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStarsNew.
 */
template<class T> Callback_IIFServer_SetStarsNewPtr
newCallback_IIFServer_SetStarsNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStarsNew<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStarsNew.
 */
template<class T> Callback_IIFServer_SetStarsNewPtr
newCallback_IIFServer_SetStarsNew(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStarsNew<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStarsNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStarsNew.
 */
template<class T, typename CT>
class Callback_IIFServer_SetStarsNew : public Callback_IIFServer_SetStarsNew_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetStarsNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStarsNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStarsNew.
 */
template<class T, typename CT> Callback_IIFServer_SetStarsNewPtr
newCallback_IIFServer_SetStarsNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStarsNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStarsNew.
 */
template<class T, typename CT> Callback_IIFServer_SetStarsNewPtr
newCallback_IIFServer_SetStarsNew(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStarsNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars2.
 */
template<class T>
class CallbackNC_IIFServer_SetStars2 : public Callback_IIFServer_SetStars2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetStars2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStars2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars2.
 */
template<class T> Callback_IIFServer_SetStars2Ptr
newCallback_IIFServer_SetStars2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStars2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars2.
 */
template<class T> Callback_IIFServer_SetStars2Ptr
newCallback_IIFServer_SetStars2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetStars2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetStars2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetStars2.
 */
template<class T, typename CT>
class Callback_IIFServer_SetStars2 : public Callback_IIFServer_SetStars2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetStars2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetStars2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars2.
 */
template<class T, typename CT> Callback_IIFServer_SetStars2Ptr
newCallback_IIFServer_SetStars2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStars2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetStars2.
 */
template<class T, typename CT> Callback_IIFServer_SetStars2Ptr
newCallback_IIFServer_SetStars2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetStars2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearStars.
 */
template<class T>
class CallbackNC_IIFServer_ClearStars : public Callback_IIFServer_ClearStars_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearStars(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearStars(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearStars.
 */
template<class T> Callback_IIFServer_ClearStarsPtr
newCallback_IIFServer_ClearStars(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearStars<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearStars.
 */
template<class T> Callback_IIFServer_ClearStarsPtr
newCallback_IIFServer_ClearStars(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearStars<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearStars.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearStars.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearStars : public Callback_IIFServer_ClearStars_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearStars(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearStars(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearStars.
 */
template<class T, typename CT> Callback_IIFServer_ClearStarsPtr
newCallback_IIFServer_ClearStars(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearStars<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearStars.
 */
template<class T, typename CT> Callback_IIFServer_ClearStarsPtr
newCallback_IIFServer_ClearStars(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearStars<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetHotspot.
 */
template<class T>
class CallbackNC_IIFServer_SetHotspot : public Callback_IIFServer_SetHotspot_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetHotspot.
 */
template<class T> Callback_IIFServer_SetHotspotPtr
newCallback_IIFServer_SetHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetHotspot.
 */
template<class T> Callback_IIFServer_SetHotspotPtr
newCallback_IIFServer_SetHotspot(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetHotspot.
 */
template<class T, typename CT>
class Callback_IIFServer_SetHotspot : public Callback_IIFServer_SetHotspot_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetHotspot.
 */
template<class T, typename CT> Callback_IIFServer_SetHotspotPtr
newCallback_IIFServer_SetHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetHotspot.
 */
template<class T, typename CT> Callback_IIFServer_SetHotspotPtr
newCallback_IIFServer_SetHotspot(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearHotspot.
 */
template<class T>
class CallbackNC_IIFServer_ClearHotspot : public Callback_IIFServer_ClearHotspot_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearHotspot.
 */
template<class T> Callback_IIFServer_ClearHotspotPtr
newCallback_IIFServer_ClearHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearHotspot.
 */
template<class T> Callback_IIFServer_ClearHotspotPtr
newCallback_IIFServer_ClearHotspot(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearHotspot.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearHotspot : public Callback_IIFServer_ClearHotspot_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearHotspot.
 */
template<class T, typename CT> Callback_IIFServer_ClearHotspotPtr
newCallback_IIFServer_ClearHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearHotspot.
 */
template<class T, typename CT> Callback_IIFServer_ClearHotspotPtr
newCallback_IIFServer_ClearHotspot(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset.
 */
template<class T>
class CallbackNC_IIFServer_SetOffset : public Callback_IIFServer_SetOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset.
 */
template<class T> Callback_IIFServer_SetOffsetPtr
newCallback_IIFServer_SetOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffset<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset.
 */
template<class T> Callback_IIFServer_SetOffsetPtr
newCallback_IIFServer_SetOffset(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffset<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset.
 */
template<class T, typename CT>
class Callback_IIFServer_SetOffset : public Callback_IIFServer_SetOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset.
 */
template<class T, typename CT> Callback_IIFServer_SetOffsetPtr
newCallback_IIFServer_SetOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset.
 */
template<class T, typename CT> Callback_IIFServer_SetOffsetPtr
newCallback_IIFServer_SetOffset(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffsetNew.
 */
template<class T>
class CallbackNC_IIFServer_SetOffsetNew : public Callback_IIFServer_SetOffsetNew_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetOffsetNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffsetNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 */
template<class T> Callback_IIFServer_SetOffsetNewPtr
newCallback_IIFServer_SetOffsetNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffsetNew<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 */
template<class T> Callback_IIFServer_SetOffsetNewPtr
newCallback_IIFServer_SetOffsetNew(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffsetNew<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffsetNew.
 */
template<class T, typename CT>
class Callback_IIFServer_SetOffsetNew : public Callback_IIFServer_SetOffsetNew_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetOffsetNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffsetNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 */
template<class T, typename CT> Callback_IIFServer_SetOffsetNewPtr
newCallback_IIFServer_SetOffsetNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffsetNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffsetNew.
 */
template<class T, typename CT> Callback_IIFServer_SetOffsetNewPtr
newCallback_IIFServer_SetOffsetNew(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffsetNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset2.
 */
template<class T>
class CallbackNC_IIFServer_SetOffset2 : public Callback_IIFServer_SetOffset2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetOffset2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffset2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset2.
 */
template<class T> Callback_IIFServer_SetOffset2Ptr
newCallback_IIFServer_SetOffset2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffset2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset2.
 */
template<class T> Callback_IIFServer_SetOffset2Ptr
newCallback_IIFServer_SetOffset2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetOffset2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetOffset2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetOffset2.
 */
template<class T, typename CT>
class Callback_IIFServer_SetOffset2 : public Callback_IIFServer_SetOffset2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetOffset2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetOffset2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset2.
 */
template<class T, typename CT> Callback_IIFServer_SetOffset2Ptr
newCallback_IIFServer_SetOffset2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffset2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetOffset2.
 */
template<class T, typename CT> Callback_IIFServer_SetOffset2Ptr
newCallback_IIFServer_SetOffset2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetOffset2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearOffset.
 */
template<class T>
class CallbackNC_IIFServer_ClearOffset : public Callback_IIFServer_ClearOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearOffset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearOffset.
 */
template<class T> Callback_IIFServer_ClearOffsetPtr
newCallback_IIFServer_ClearOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearOffset<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearOffset.
 */
template<class T> Callback_IIFServer_ClearOffsetPtr
newCallback_IIFServer_ClearOffset(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearOffset<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearOffset.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearOffset.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearOffset : public Callback_IIFServer_ClearOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearOffset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearOffset.
 */
template<class T, typename CT> Callback_IIFServer_ClearOffsetPtr
newCallback_IIFServer_ClearOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearOffset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearOffset.
 */
template<class T, typename CT> Callback_IIFServer_ClearOffsetPtr
newCallback_IIFServer_ClearOffset(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearOffset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSidereal.
 */
template<class T>
class CallbackNC_IIFServer_SetNonSidereal : public Callback_IIFServer_SetNonSidereal_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetNonSidereal(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetNonSidereal(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 */
template<class T> Callback_IIFServer_SetNonSiderealPtr
newCallback_IIFServer_SetNonSidereal(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetNonSidereal<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 */
template<class T> Callback_IIFServer_SetNonSiderealPtr
newCallback_IIFServer_SetNonSidereal(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetNonSidereal<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSidereal.
 */
template<class T, typename CT>
class Callback_IIFServer_SetNonSidereal : public Callback_IIFServer_SetNonSidereal_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetNonSidereal(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetNonSidereal(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 */
template<class T, typename CT> Callback_IIFServer_SetNonSiderealPtr
newCallback_IIFServer_SetNonSidereal(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetNonSidereal<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSidereal.
 */
template<class T, typename CT> Callback_IIFServer_SetNonSiderealPtr
newCallback_IIFServer_SetNonSidereal(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetNonSidereal<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSidereal.
 */
template<class T>
class CallbackNC_IIFServer_ClearNonSidereal : public Callback_IIFServer_ClearNonSidereal_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearNonSidereal(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearNonSidereal(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 */
template<class T> Callback_IIFServer_ClearNonSiderealPtr
newCallback_IIFServer_ClearNonSidereal(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearNonSidereal<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 */
template<class T> Callback_IIFServer_ClearNonSiderealPtr
newCallback_IIFServer_ClearNonSidereal(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearNonSidereal<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSidereal.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearNonSidereal : public Callback_IIFServer_ClearNonSidereal_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearNonSidereal(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearNonSidereal(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 */
template<class T, typename CT> Callback_IIFServer_ClearNonSiderealPtr
newCallback_IIFServer_ClearNonSidereal(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearNonSidereal<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSidereal.
 */
template<class T, typename CT> Callback_IIFServer_ClearNonSiderealPtr
newCallback_IIFServer_ClearNonSidereal(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearNonSidereal<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealTarget.
 */
template<class T>
class CallbackNC_IIFServer_UpdateNonSiderealTarget : public Callback_IIFServer_UpdateNonSiderealTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_UpdateNonSiderealTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateNonSiderealTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 */
template<class T> Callback_IIFServer_UpdateNonSiderealTargetPtr
newCallback_IIFServer_UpdateNonSiderealTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateNonSiderealTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 */
template<class T> Callback_IIFServer_UpdateNonSiderealTargetPtr
newCallback_IIFServer_UpdateNonSiderealTarget(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateNonSiderealTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealTarget.
 */
template<class T, typename CT>
class Callback_IIFServer_UpdateNonSiderealTarget : public Callback_IIFServer_UpdateNonSiderealTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_UpdateNonSiderealTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateNonSiderealTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 */
template<class T, typename CT> Callback_IIFServer_UpdateNonSiderealTargetPtr
newCallback_IIFServer_UpdateNonSiderealTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateNonSiderealTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealTarget.
 */
template<class T, typename CT> Callback_IIFServer_UpdateNonSiderealTargetPtr
newCallback_IIFServer_UpdateNonSiderealTarget(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateNonSiderealTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSiderealObject.
 */
template<class T>
class CallbackNC_IIFServer_SetNonSiderealObject : public Callback_IIFServer_SetNonSiderealObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 */
template<class T> Callback_IIFServer_SetNonSiderealObjectPtr
newCallback_IIFServer_SetNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 */
template<class T> Callback_IIFServer_SetNonSiderealObjectPtr
newCallback_IIFServer_SetNonSiderealObject(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetNonSiderealObject.
 */
template<class T, typename CT>
class Callback_IIFServer_SetNonSiderealObject : public Callback_IIFServer_SetNonSiderealObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_SetNonSiderealObjectPtr
newCallback_IIFServer_SetNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_SetNonSiderealObjectPtr
newCallback_IIFServer_SetNonSiderealObject(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSiderealObject.
 */
template<class T>
class CallbackNC_IIFServer_ClearNonSiderealObject : public Callback_IIFServer_ClearNonSiderealObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 */
template<class T> Callback_IIFServer_ClearNonSiderealObjectPtr
newCallback_IIFServer_ClearNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 */
template<class T> Callback_IIFServer_ClearNonSiderealObjectPtr
newCallback_IIFServer_ClearNonSiderealObject(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearNonSiderealObject.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearNonSiderealObject : public Callback_IIFServer_ClearNonSiderealObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_ClearNonSiderealObjectPtr
newCallback_IIFServer_ClearNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_ClearNonSiderealObjectPtr
newCallback_IIFServer_ClearNonSiderealObject(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealObject.
 */
template<class T>
class CallbackNC_IIFServer_UpdateNonSiderealObject : public Callback_IIFServer_UpdateNonSiderealObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_UpdateNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 */
template<class T> Callback_IIFServer_UpdateNonSiderealObjectPtr
newCallback_IIFServer_UpdateNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 */
template<class T> Callback_IIFServer_UpdateNonSiderealObjectPtr
newCallback_IIFServer_UpdateNonSiderealObject(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateNonSiderealObject<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateNonSiderealObject.
 */
template<class T, typename CT>
class Callback_IIFServer_UpdateNonSiderealObject : public Callback_IIFServer_UpdateNonSiderealObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_UpdateNonSiderealObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateNonSiderealObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_UpdateNonSiderealObjectPtr
newCallback_IIFServer_UpdateNonSiderealObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateNonSiderealObject.
 */
template<class T, typename CT> Callback_IIFServer_UpdateNonSiderealObjectPtr
newCallback_IIFServer_UpdateNonSiderealObject(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateNonSiderealObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetTelescope.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetTelescope.
 */
template<class T>
class CallbackNC_IIFServer_PresetTelescope : public Callback_IIFServer_PresetTelescope_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_PresetTelescope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetTelescope(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetTelescope.
 */
template<class T> Callback_IIFServer_PresetTelescopePtr
newCallback_IIFServer_PresetTelescope(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetTelescope<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetTelescope.
 */
template<class T> Callback_IIFServer_PresetTelescopePtr
newCallback_IIFServer_PresetTelescope(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetTelescope<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetTelescope.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetTelescope.
 */
template<class T, typename CT>
class Callback_IIFServer_PresetTelescope : public Callback_IIFServer_PresetTelescope_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_PresetTelescope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetTelescope(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetTelescope.
 */
template<class T, typename CT> Callback_IIFServer_PresetTelescopePtr
newCallback_IIFServer_PresetTelescope(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetTelescope<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetTelescope.
 */
template<class T, typename CT> Callback_IIFServer_PresetTelescopePtr
newCallback_IIFServer_PresetTelescope(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetTelescope<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_BinocularControl.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_BinocularControl.
 */
template<class T>
class CallbackNC_IIFServer_BinocularControl : public Callback_IIFServer_BinocularControl_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_BinocularControl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_BinocularControl(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_BinocularControl.
 */
template<class T> Callback_IIFServer_BinocularControlPtr
newCallback_IIFServer_BinocularControl(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_BinocularControl<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_BinocularControl.
 */
template<class T> Callback_IIFServer_BinocularControlPtr
newCallback_IIFServer_BinocularControl(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_BinocularControl<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_BinocularControl.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_BinocularControl.
 */
template<class T, typename CT>
class Callback_IIFServer_BinocularControl : public Callback_IIFServer_BinocularControl_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_BinocularControl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_BinocularControl(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_BinocularControl.
 */
template<class T, typename CT> Callback_IIFServer_BinocularControlPtr
newCallback_IIFServer_BinocularControl(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_BinocularControl<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_BinocularControl.
 */
template<class T, typename CT> Callback_IIFServer_BinocularControlPtr
newCallback_IIFServer_BinocularControl(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_BinocularControl<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetParameter.
 */
template<class T>
class CallbackNC_IIFServer_GetParameter : public Callback_IIFServer_GetParameter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetParameter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetParameter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetParameter.
 */
template<class T> Callback_IIFServer_GetParameterPtr
newCallback_IIFServer_GetParameter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetParameter<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetParameter.
 */
template<class T> Callback_IIFServer_GetParameterPtr
newCallback_IIFServer_GetParameter(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetParameter<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetParameter.
 */
template<class T, typename CT>
class Callback_IIFServer_GetParameter : public Callback_IIFServer_GetParameter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetParameter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetParameter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetParameter.
 */
template<class T, typename CT> Callback_IIFServer_GetParameterPtr
newCallback_IIFServer_GetParameter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetParameter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetParameter.
 */
template<class T, typename CT> Callback_IIFServer_GetParameterPtr
newCallback_IIFServer_GetParameter(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetParameter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetParameter.
 */
template<class T>
class CallbackNC_IIFServer_SetParameter : public Callback_IIFServer_SetParameter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetParameter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetParameter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetParameter.
 */
template<class T> Callback_IIFServer_SetParameterPtr
newCallback_IIFServer_SetParameter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetParameter<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetParameter.
 */
template<class T> Callback_IIFServer_SetParameterPtr
newCallback_IIFServer_SetParameter(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetParameter<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetParameter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetParameter.
 */
template<class T, typename CT>
class Callback_IIFServer_SetParameter : public Callback_IIFServer_SetParameter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetParameter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetParameter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetParameter.
 */
template<class T, typename CT> Callback_IIFServer_SetParameterPtr
newCallback_IIFServer_SetParameter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetParameter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetParameter.
 */
template<class T, typename CT> Callback_IIFServer_SetParameterPtr
newCallback_IIFServer_SetParameter(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetParameter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateCommon.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateCommon.
 */
template<class T>
class CallbackNC_IIFServer_RotateCommon : public Callback_IIFServer_RotateCommon_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotateCommon(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotateCommon(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateCommon.
 */
template<class T> Callback_IIFServer_RotateCommonPtr
newCallback_IIFServer_RotateCommon(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotateCommon<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateCommon.
 */
template<class T> Callback_IIFServer_RotateCommonPtr
newCallback_IIFServer_RotateCommon(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotateCommon<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateCommon.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateCommon.
 */
template<class T, typename CT>
class Callback_IIFServer_RotateCommon : public Callback_IIFServer_RotateCommon_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotateCommon(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotateCommon(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateCommon.
 */
template<class T, typename CT> Callback_IIFServer_RotateCommonPtr
newCallback_IIFServer_RotateCommon(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotateCommon<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateCommon.
 */
template<class T, typename CT> Callback_IIFServer_RotateCommonPtr
newCallback_IIFServer_RotateCommon(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotateCommon<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateZ.
 */
template<class T>
class CallbackNC_IIFServer_RotateZ : public Callback_IIFServer_RotateZ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotateZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotateZ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateZ.
 */
template<class T> Callback_IIFServer_RotateZPtr
newCallback_IIFServer_RotateZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotateZ<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateZ.
 */
template<class T> Callback_IIFServer_RotateZPtr
newCallback_IIFServer_RotateZ(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotateZ<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotateZ.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotateZ.
 */
template<class T, typename CT>
class Callback_IIFServer_RotateZ : public Callback_IIFServer_RotateZ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotateZ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotateZ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateZ.
 */
template<class T, typename CT> Callback_IIFServer_RotateZPtr
newCallback_IIFServer_RotateZ(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotateZ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotateZ.
 */
template<class T, typename CT> Callback_IIFServer_RotateZPtr
newCallback_IIFServer_RotateZ(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotateZ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotatePrimary.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotatePrimary.
 */
template<class T>
class CallbackNC_IIFServer_RotatePrimary : public Callback_IIFServer_RotatePrimary_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotatePrimary(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotatePrimary(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotatePrimary.
 */
template<class T> Callback_IIFServer_RotatePrimaryPtr
newCallback_IIFServer_RotatePrimary(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotatePrimary<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotatePrimary.
 */
template<class T> Callback_IIFServer_RotatePrimaryPtr
newCallback_IIFServer_RotatePrimary(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotatePrimary<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotatePrimary.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotatePrimary.
 */
template<class T, typename CT>
class Callback_IIFServer_RotatePrimary : public Callback_IIFServer_RotatePrimary_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotatePrimary(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotatePrimary(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotatePrimary.
 */
template<class T, typename CT> Callback_IIFServer_RotatePrimaryPtr
newCallback_IIFServer_RotatePrimary(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotatePrimary<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotatePrimary.
 */
template<class T, typename CT> Callback_IIFServer_RotatePrimaryPtr
newCallback_IIFServer_RotatePrimary(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotatePrimary<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SendWavefront.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SendWavefront.
 */
template<class T>
class CallbackNC_IIFServer_SendWavefront : public Callback_IIFServer_SendWavefront_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SendWavefront(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SendWavefront(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SendWavefront.
 */
template<class T> Callback_IIFServer_SendWavefrontPtr
newCallback_IIFServer_SendWavefront(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SendWavefront<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SendWavefront.
 */
template<class T> Callback_IIFServer_SendWavefrontPtr
newCallback_IIFServer_SendWavefront(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SendWavefront<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SendWavefront.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SendWavefront.
 */
template<class T, typename CT>
class Callback_IIFServer_SendWavefront : public Callback_IIFServer_SendWavefront_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SendWavefront(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SendWavefront(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SendWavefront.
 */
template<class T, typename CT> Callback_IIFServer_SendWavefrontPtr
newCallback_IIFServer_SendWavefront(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SendWavefront<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SendWavefront.
 */
template<class T, typename CT> Callback_IIFServer_SendWavefrontPtr
newCallback_IIFServer_SendWavefront(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SendWavefront<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateTargetWavelength.
 */
template<class T>
class CallbackNC_IIFServer_UpdateTargetWavelength : public Callback_IIFServer_UpdateTargetWavelength_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_UpdateTargetWavelength(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateTargetWavelength(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 */
template<class T> Callback_IIFServer_UpdateTargetWavelengthPtr
newCallback_IIFServer_UpdateTargetWavelength(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateTargetWavelength<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 */
template<class T> Callback_IIFServer_UpdateTargetWavelengthPtr
newCallback_IIFServer_UpdateTargetWavelength(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_UpdateTargetWavelength<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_UpdateTargetWavelength.
 */
template<class T, typename CT>
class Callback_IIFServer_UpdateTargetWavelength : public Callback_IIFServer_UpdateTargetWavelength_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_UpdateTargetWavelength(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_UpdateTargetWavelength(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 */
template<class T, typename CT> Callback_IIFServer_UpdateTargetWavelengthPtr
newCallback_IIFServer_UpdateTargetWavelength(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateTargetWavelength<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_UpdateTargetWavelength.
 */
template<class T, typename CT> Callback_IIFServer_UpdateTargetWavelengthPtr
newCallback_IIFServer_UpdateTargetWavelength(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_UpdateTargetWavelength<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_LogEvent.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_LogEvent.
 */
template<class T>
class CallbackNC_IIFServer_LogEvent : public Callback_IIFServer_LogEvent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_LogEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_LogEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_LogEvent.
 */
template<class T> Callback_IIFServer_LogEventPtr
newCallback_IIFServer_LogEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_LogEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_LogEvent.
 */
template<class T> Callback_IIFServer_LogEventPtr
newCallback_IIFServer_LogEvent(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_LogEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_LogEvent.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_LogEvent.
 */
template<class T, typename CT>
class Callback_IIFServer_LogEvent : public Callback_IIFServer_LogEvent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_LogEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_LogEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_LogEvent.
 */
template<class T, typename CT> Callback_IIFServer_LogEventPtr
newCallback_IIFServer_LogEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_LogEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_LogEvent.
 */
template<class T, typename CT> Callback_IIFServer_LogEventPtr
newCallback_IIFServer_LogEvent(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_LogEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorTrajectory.
 */
template<class T>
class CallbackNC_IIFServer_GetRotatorTrajectory : public Callback_IIFServer_GetRotatorTrajectory_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetRotatorTrajectory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetRotatorTrajectory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 */
template<class T> Callback_IIFServer_GetRotatorTrajectoryPtr
newCallback_IIFServer_GetRotatorTrajectory(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetRotatorTrajectory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 */
template<class T> Callback_IIFServer_GetRotatorTrajectoryPtr
newCallback_IIFServer_GetRotatorTrajectory(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetRotatorTrajectory<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorTrajectory.
 */
template<class T, typename CT>
class Callback_IIFServer_GetRotatorTrajectory : public Callback_IIFServer_GetRotatorTrajectory_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetRotatorTrajectory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetRotatorTrajectory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 */
template<class T, typename CT> Callback_IIFServer_GetRotatorTrajectoryPtr
newCallback_IIFServer_GetRotatorTrajectory(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetRotatorTrajectory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorTrajectory.
 */
template<class T, typename CT> Callback_IIFServer_GetRotatorTrajectoryPtr
newCallback_IIFServer_GetRotatorTrajectory(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetRotatorTrajectory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorPolynomials.
 */
template<class T>
class CallbackNC_IIFServer_GetRotatorPolynomials : public Callback_IIFServer_GetRotatorPolynomials_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetRotatorPolynomials(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetRotatorPolynomials(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 */
template<class T> Callback_IIFServer_GetRotatorPolynomialsPtr
newCallback_IIFServer_GetRotatorPolynomials(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetRotatorPolynomials<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 */
template<class T> Callback_IIFServer_GetRotatorPolynomialsPtr
newCallback_IIFServer_GetRotatorPolynomials(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetRotatorPolynomials<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetRotatorPolynomials.
 */
template<class T, typename CT>
class Callback_IIFServer_GetRotatorPolynomials : public Callback_IIFServer_GetRotatorPolynomials_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetRotatorPolynomials(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetRotatorPolynomials(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 */
template<class T, typename CT> Callback_IIFServer_GetRotatorPolynomialsPtr
newCallback_IIFServer_GetRotatorPolynomials(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetRotatorPolynomials<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetRotatorPolynomials.
 */
template<class T, typename CT> Callback_IIFServer_GetRotatorPolynomialsPtr
newCallback_IIFServer_GetRotatorPolynomials(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetRotatorPolynomials<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_Standby.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Standby.
 */
template<class T>
class CallbackNC_IIFServer_Standby : public Callback_IIFServer_Standby_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_Standby(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Standby(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Standby.
 */
template<class T> Callback_IIFServer_StandbyPtr
newCallback_IIFServer_Standby(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Standby<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Standby.
 */
template<class T> Callback_IIFServer_StandbyPtr
newCallback_IIFServer_Standby(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_Standby<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_Standby.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_Standby.
 */
template<class T, typename CT>
class Callback_IIFServer_Standby : public Callback_IIFServer_Standby_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_Standby(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_Standby(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Standby.
 */
template<class T, typename CT> Callback_IIFServer_StandbyPtr
newCallback_IIFServer_Standby(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Standby<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_Standby.
 */
template<class T, typename CT> Callback_IIFServer_StandbyPtr
newCallback_IIFServer_Standby(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_Standby<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MaximizeWrapTime.
 */
template<class T>
class CallbackNC_IIFServer_MaximizeWrapTime : public Callback_IIFServer_MaximizeWrapTime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_MaximizeWrapTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MaximizeWrapTime(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 */
template<class T> Callback_IIFServer_MaximizeWrapTimePtr
newCallback_IIFServer_MaximizeWrapTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MaximizeWrapTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 */
template<class T> Callback_IIFServer_MaximizeWrapTimePtr
newCallback_IIFServer_MaximizeWrapTime(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_MaximizeWrapTime<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_MaximizeWrapTime.
 */
template<class T, typename CT>
class Callback_IIFServer_MaximizeWrapTime : public Callback_IIFServer_MaximizeWrapTime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_MaximizeWrapTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_MaximizeWrapTime(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 */
template<class T, typename CT> Callback_IIFServer_MaximizeWrapTimePtr
newCallback_IIFServer_MaximizeWrapTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MaximizeWrapTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_MaximizeWrapTime.
 */
template<class T, typename CT> Callback_IIFServer_MaximizeWrapTimePtr
newCallback_IIFServer_MaximizeWrapTime(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_MaximizeWrapTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseGuiding.
 */
template<class T>
class CallbackNC_IIFServer_PauseGuiding : public Callback_IIFServer_PauseGuiding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_PauseGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PauseGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseGuiding.
 */
template<class T> Callback_IIFServer_PauseGuidingPtr
newCallback_IIFServer_PauseGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PauseGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseGuiding.
 */
template<class T> Callback_IIFServer_PauseGuidingPtr
newCallback_IIFServer_PauseGuiding(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PauseGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseGuiding.
 */
template<class T, typename CT>
class Callback_IIFServer_PauseGuiding : public Callback_IIFServer_PauseGuiding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_PauseGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PauseGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseGuiding.
 */
template<class T, typename CT> Callback_IIFServer_PauseGuidingPtr
newCallback_IIFServer_PauseGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PauseGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseGuiding.
 */
template<class T, typename CT> Callback_IIFServer_PauseGuidingPtr
newCallback_IIFServer_PauseGuiding(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PauseGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeGuiding.
 */
template<class T>
class CallbackNC_IIFServer_ResumeGuiding : public Callback_IIFServer_ResumeGuiding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ResumeGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ResumeGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 */
template<class T> Callback_IIFServer_ResumeGuidingPtr
newCallback_IIFServer_ResumeGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ResumeGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 */
template<class T> Callback_IIFServer_ResumeGuidingPtr
newCallback_IIFServer_ResumeGuiding(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ResumeGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeGuiding.
 */
template<class T, typename CT>
class Callback_IIFServer_ResumeGuiding : public Callback_IIFServer_ResumeGuiding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ResumeGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ResumeGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 */
template<class T, typename CT> Callback_IIFServer_ResumeGuidingPtr
newCallback_IIFServer_ResumeGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ResumeGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeGuiding.
 */
template<class T, typename CT> Callback_IIFServer_ResumeGuidingPtr
newCallback_IIFServer_ResumeGuiding(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ResumeGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_StopGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopGuiding.
 */
template<class T>
class CallbackNC_IIFServer_StopGuiding : public Callback_IIFServer_StopGuiding_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_StopGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StopGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopGuiding.
 */
template<class T> Callback_IIFServer_StopGuidingPtr
newCallback_IIFServer_StopGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StopGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopGuiding.
 */
template<class T> Callback_IIFServer_StopGuidingPtr
newCallback_IIFServer_StopGuiding(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StopGuiding<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_StopGuiding.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopGuiding.
 */
template<class T, typename CT>
class Callback_IIFServer_StopGuiding : public Callback_IIFServer_StopGuiding_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_StopGuiding(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StopGuiding(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopGuiding.
 */
template<class T, typename CT> Callback_IIFServer_StopGuidingPtr
newCallback_IIFServer_StopGuiding(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StopGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopGuiding.
 */
template<class T, typename CT> Callback_IIFServer_StopGuidingPtr
newCallback_IIFServer_StopGuiding(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StopGuiding<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingHotspot.
 */
template<class T>
class CallbackNC_IIFServer_SetGuidingHotspot : public Callback_IIFServer_SetGuidingHotspot_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetGuidingHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetGuidingHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 */
template<class T> Callback_IIFServer_SetGuidingHotspotPtr
newCallback_IIFServer_SetGuidingHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetGuidingHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 */
template<class T> Callback_IIFServer_SetGuidingHotspotPtr
newCallback_IIFServer_SetGuidingHotspot(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetGuidingHotspot<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingHotspot.
 */
template<class T, typename CT>
class Callback_IIFServer_SetGuidingHotspot : public Callback_IIFServer_SetGuidingHotspot_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetGuidingHotspot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetGuidingHotspot(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 */
template<class T, typename CT> Callback_IIFServer_SetGuidingHotspotPtr
newCallback_IIFServer_SetGuidingHotspot(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetGuidingHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingHotspot.
 */
template<class T, typename CT> Callback_IIFServer_SetGuidingHotspotPtr
newCallback_IIFServer_SetGuidingHotspot(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetGuidingHotspot<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetAGWFilter.
 */
template<class T>
class CallbackNC_IIFServer_SetAGWFilter : public Callback_IIFServer_SetAGWFilter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetAGWFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetAGWFilter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 */
template<class T> Callback_IIFServer_SetAGWFilterPtr
newCallback_IIFServer_SetAGWFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetAGWFilter<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 */
template<class T> Callback_IIFServer_SetAGWFilterPtr
newCallback_IIFServer_SetAGWFilter(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetAGWFilter<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetAGWFilter.
 */
template<class T, typename CT>
class Callback_IIFServer_SetAGWFilter : public Callback_IIFServer_SetAGWFilter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetAGWFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetAGWFilter(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 */
template<class T, typename CT> Callback_IIFServer_SetAGWFilterPtr
newCallback_IIFServer_SetAGWFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetAGWFilter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetAGWFilter.
 */
template<class T, typename CT> Callback_IIFServer_SetAGWFilterPtr
newCallback_IIFServer_SetAGWFilter(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetAGWFilter<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingBinning.
 */
template<class T>
class CallbackNC_IIFServer_SetGuidingBinning : public Callback_IIFServer_SetGuidingBinning_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetGuidingBinning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetGuidingBinning(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 */
template<class T> Callback_IIFServer_SetGuidingBinningPtr
newCallback_IIFServer_SetGuidingBinning(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetGuidingBinning<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 */
template<class T> Callback_IIFServer_SetGuidingBinningPtr
newCallback_IIFServer_SetGuidingBinning(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetGuidingBinning<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetGuidingBinning.
 */
template<class T, typename CT>
class Callback_IIFServer_SetGuidingBinning : public Callback_IIFServer_SetGuidingBinning_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetGuidingBinning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetGuidingBinning(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 */
template<class T, typename CT> Callback_IIFServer_SetGuidingBinningPtr
newCallback_IIFServer_SetGuidingBinning(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetGuidingBinning<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetGuidingBinning.
 */
template<class T, typename CT> Callback_IIFServer_SetGuidingBinningPtr
newCallback_IIFServer_SetGuidingBinning(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetGuidingBinning<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotReady.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotReady.
 */
template<class T>
class CallbackNC_IIFServer_RotReady : public Callback_IIFServer_RotReady_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotReady(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotReady.
 */
template<class T> Callback_IIFServer_RotReadyPtr
newCallback_IIFServer_RotReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotReady<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotReady.
 */
template<class T> Callback_IIFServer_RotReadyPtr
newCallback_IIFServer_RotReady(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotReady<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotReady.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotReady.
 */
template<class T, typename CT>
class Callback_IIFServer_RotReady : public Callback_IIFServer_RotReady_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotReady(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotReady.
 */
template<class T, typename CT> Callback_IIFServer_RotReadyPtr
newCallback_IIFServer_RotReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotReady.
 */
template<class T, typename CT> Callback_IIFServer_RotReadyPtr
newCallback_IIFServer_RotReady(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotReady<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotHold.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotHold.
 */
template<class T>
class CallbackNC_IIFServer_RotHold : public Callback_IIFServer_RotHold_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotHold(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotHold(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotHold.
 */
template<class T> Callback_IIFServer_RotHoldPtr
newCallback_IIFServer_RotHold(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotHold<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotHold.
 */
template<class T> Callback_IIFServer_RotHoldPtr
newCallback_IIFServer_RotHold(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotHold<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotHold.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotHold.
 */
template<class T, typename CT>
class Callback_IIFServer_RotHold : public Callback_IIFServer_RotHold_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotHold(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotHold(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotHold.
 */
template<class T, typename CT> Callback_IIFServer_RotHoldPtr
newCallback_IIFServer_RotHold(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotHold<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotHold.
 */
template<class T, typename CT> Callback_IIFServer_RotHoldPtr
newCallback_IIFServer_RotHold(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotHold<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotTrack.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotTrack.
 */
template<class T>
class CallbackNC_IIFServer_RotTrack : public Callback_IIFServer_RotTrack_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotTrack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotTrack(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotTrack.
 */
template<class T> Callback_IIFServer_RotTrackPtr
newCallback_IIFServer_RotTrack(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotTrack<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotTrack.
 */
template<class T> Callback_IIFServer_RotTrackPtr
newCallback_IIFServer_RotTrack(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotTrack<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotTrack.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotTrack.
 */
template<class T, typename CT>
class Callback_IIFServer_RotTrack : public Callback_IIFServer_RotTrack_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotTrack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotTrack(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotTrack.
 */
template<class T, typename CT> Callback_IIFServer_RotTrackPtr
newCallback_IIFServer_RotTrack(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotTrack<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotTrack.
 */
template<class T, typename CT> Callback_IIFServer_RotTrackPtr
newCallback_IIFServer_RotTrack(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotTrack<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RotServicePosition.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotServicePosition.
 */
template<class T>
class CallbackNC_IIFServer_RotServicePosition : public Callback_IIFServer_RotServicePosition_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RotServicePosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotServicePosition(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotServicePosition.
 */
template<class T> Callback_IIFServer_RotServicePositionPtr
newCallback_IIFServer_RotServicePosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotServicePosition<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotServicePosition.
 */
template<class T> Callback_IIFServer_RotServicePositionPtr
newCallback_IIFServer_RotServicePosition(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RotServicePosition<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RotServicePosition.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RotServicePosition.
 */
template<class T, typename CT>
class Callback_IIFServer_RotServicePosition : public Callback_IIFServer_RotServicePosition_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RotServicePosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RotServicePosition(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotServicePosition.
 */
template<class T, typename CT> Callback_IIFServer_RotServicePositionPtr
newCallback_IIFServer_RotServicePosition(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotServicePosition<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RotServicePosition.
 */
template<class T, typename CT> Callback_IIFServer_RotServicePositionPtr
newCallback_IIFServer_RotServicePosition(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RotServicePosition<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseAO.
 */
template<class T>
class CallbackNC_IIFServer_PauseAO : public Callback_IIFServer_PauseAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_PauseAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PauseAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseAO.
 */
template<class T> Callback_IIFServer_PauseAOPtr
newCallback_IIFServer_PauseAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PauseAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseAO.
 */
template<class T> Callback_IIFServer_PauseAOPtr
newCallback_IIFServer_PauseAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PauseAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_PauseAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PauseAO.
 */
template<class T, typename CT>
class Callback_IIFServer_PauseAO : public Callback_IIFServer_PauseAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_PauseAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PauseAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseAO.
 */
template<class T, typename CT> Callback_IIFServer_PauseAOPtr
newCallback_IIFServer_PauseAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PauseAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PauseAO.
 */
template<class T, typename CT> Callback_IIFServer_PauseAOPtr
newCallback_IIFServer_PauseAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PauseAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeAO.
 */
template<class T>
class CallbackNC_IIFServer_ResumeAO : public Callback_IIFServer_ResumeAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ResumeAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ResumeAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeAO.
 */
template<class T> Callback_IIFServer_ResumeAOPtr
newCallback_IIFServer_ResumeAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ResumeAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeAO.
 */
template<class T> Callback_IIFServer_ResumeAOPtr
newCallback_IIFServer_ResumeAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ResumeAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ResumeAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ResumeAO.
 */
template<class T, typename CT>
class Callback_IIFServer_ResumeAO : public Callback_IIFServer_ResumeAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ResumeAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ResumeAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeAO.
 */
template<class T, typename CT> Callback_IIFServer_ResumeAOPtr
newCallback_IIFServer_ResumeAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ResumeAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ResumeAO.
 */
template<class T, typename CT> Callback_IIFServer_ResumeAOPtr
newCallback_IIFServer_ResumeAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ResumeAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_StartAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StartAO.
 */
template<class T>
class CallbackNC_IIFServer_StartAO : public Callback_IIFServer_StartAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_StartAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StartAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StartAO.
 */
template<class T> Callback_IIFServer_StartAOPtr
newCallback_IIFServer_StartAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StartAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StartAO.
 */
template<class T> Callback_IIFServer_StartAOPtr
newCallback_IIFServer_StartAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StartAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_StartAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StartAO.
 */
template<class T, typename CT>
class Callback_IIFServer_StartAO : public Callback_IIFServer_StartAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_StartAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StartAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StartAO.
 */
template<class T, typename CT> Callback_IIFServer_StartAOPtr
newCallback_IIFServer_StartAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StartAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StartAO.
 */
template<class T, typename CT> Callback_IIFServer_StartAOPtr
newCallback_IIFServer_StartAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StartAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_StopAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopAO.
 */
template<class T>
class CallbackNC_IIFServer_StopAO : public Callback_IIFServer_StopAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_StopAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StopAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopAO.
 */
template<class T> Callback_IIFServer_StopAOPtr
newCallback_IIFServer_StopAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StopAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopAO.
 */
template<class T> Callback_IIFServer_StopAOPtr
newCallback_IIFServer_StopAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_StopAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_StopAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_StopAO.
 */
template<class T, typename CT>
class Callback_IIFServer_StopAO : public Callback_IIFServer_StopAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_StopAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_StopAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopAO.
 */
template<class T, typename CT> Callback_IIFServer_StopAOPtr
newCallback_IIFServer_StopAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StopAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_StopAO.
 */
template<class T, typename CT> Callback_IIFServer_StopAOPtr
newCallback_IIFServer_StopAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_StopAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_AcquireRefAO.
 */
template<class T>
class CallbackNC_IIFServer_AcquireRefAO : public Callback_IIFServer_AcquireRefAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_AcquireRefAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_AcquireRefAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 */
template<class T> Callback_IIFServer_AcquireRefAOPtr
newCallback_IIFServer_AcquireRefAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_AcquireRefAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 */
template<class T> Callback_IIFServer_AcquireRefAOPtr
newCallback_IIFServer_AcquireRefAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_AcquireRefAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_AcquireRefAO.
 */
template<class T, typename CT>
class Callback_IIFServer_AcquireRefAO : public Callback_IIFServer_AcquireRefAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_AcquireRefAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_AcquireRefAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 */
template<class T, typename CT> Callback_IIFServer_AcquireRefAOPtr
newCallback_IIFServer_AcquireRefAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_AcquireRefAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_AcquireRefAO.
 */
template<class T, typename CT> Callback_IIFServer_AcquireRefAOPtr
newCallback_IIFServer_AcquireRefAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_AcquireRefAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_CheckRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CheckRefAO.
 */
template<class T>
class CallbackNC_IIFServer_CheckRefAO : public Callback_IIFServer_CheckRefAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_CheckRefAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_CheckRefAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CheckRefAO.
 */
template<class T> Callback_IIFServer_CheckRefAOPtr
newCallback_IIFServer_CheckRefAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_CheckRefAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CheckRefAO.
 */
template<class T> Callback_IIFServer_CheckRefAOPtr
newCallback_IIFServer_CheckRefAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_CheckRefAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_CheckRefAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CheckRefAO.
 */
template<class T, typename CT>
class Callback_IIFServer_CheckRefAO : public Callback_IIFServer_CheckRefAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_CheckRefAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_CheckRefAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CheckRefAO.
 */
template<class T, typename CT> Callback_IIFServer_CheckRefAOPtr
newCallback_IIFServer_CheckRefAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_CheckRefAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CheckRefAO.
 */
template<class T, typename CT> Callback_IIFServer_CheckRefAOPtr
newCallback_IIFServer_CheckRefAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_CheckRefAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RefineAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RefineAO.
 */
template<class T>
class CallbackNC_IIFServer_RefineAO : public Callback_IIFServer_RefineAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RefineAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RefineAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RefineAO.
 */
template<class T> Callback_IIFServer_RefineAOPtr
newCallback_IIFServer_RefineAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RefineAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RefineAO.
 */
template<class T> Callback_IIFServer_RefineAOPtr
newCallback_IIFServer_RefineAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RefineAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RefineAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RefineAO.
 */
template<class T, typename CT>
class Callback_IIFServer_RefineAO : public Callback_IIFServer_RefineAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RefineAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RefineAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RefineAO.
 */
template<class T, typename CT> Callback_IIFServer_RefineAOPtr
newCallback_IIFServer_RefineAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RefineAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RefineAO.
 */
template<class T, typename CT> Callback_IIFServer_RefineAOPtr
newCallback_IIFServer_RefineAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RefineAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_RunAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RunAO.
 */
template<class T>
class CallbackNC_IIFServer_RunAO : public Callback_IIFServer_RunAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_RunAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RunAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RunAO.
 */
template<class T> Callback_IIFServer_RunAOPtr
newCallback_IIFServer_RunAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RunAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RunAO.
 */
template<class T> Callback_IIFServer_RunAOPtr
newCallback_IIFServer_RunAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_RunAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_RunAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_RunAO.
 */
template<class T, typename CT>
class Callback_IIFServer_RunAO : public Callback_IIFServer_RunAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_RunAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_RunAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RunAO.
 */
template<class T, typename CT> Callback_IIFServer_RunAOPtr
newCallback_IIFServer_RunAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RunAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_RunAO.
 */
template<class T, typename CT> Callback_IIFServer_RunAOPtr
newCallback_IIFServer_RunAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_RunAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetFlatAO.
 */
template<class T>
class CallbackNC_IIFServer_PresetFlatAO : public Callback_IIFServer_PresetFlatAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_PresetFlatAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetFlatAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 */
template<class T> Callback_IIFServer_PresetFlatAOPtr
newCallback_IIFServer_PresetFlatAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetFlatAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 */
template<class T> Callback_IIFServer_PresetFlatAOPtr
newCallback_IIFServer_PresetFlatAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetFlatAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetFlatAO.
 */
template<class T, typename CT>
class Callback_IIFServer_PresetFlatAO : public Callback_IIFServer_PresetFlatAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_PresetFlatAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetFlatAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 */
template<class T, typename CT> Callback_IIFServer_PresetFlatAOPtr
newCallback_IIFServer_PresetFlatAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetFlatAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetFlatAO.
 */
template<class T, typename CT> Callback_IIFServer_PresetFlatAOPtr
newCallback_IIFServer_PresetFlatAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetFlatAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CorrectModesAO.
 */
template<class T>
class CallbackNC_IIFServer_CorrectModesAO : public Callback_IIFServer_CorrectModesAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_CorrectModesAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_CorrectModesAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 */
template<class T> Callback_IIFServer_CorrectModesAOPtr
newCallback_IIFServer_CorrectModesAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_CorrectModesAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 */
template<class T> Callback_IIFServer_CorrectModesAOPtr
newCallback_IIFServer_CorrectModesAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_CorrectModesAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_CorrectModesAO.
 */
template<class T, typename CT>
class Callback_IIFServer_CorrectModesAO : public Callback_IIFServer_CorrectModesAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_CorrectModesAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_CorrectModesAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 */
template<class T, typename CT> Callback_IIFServer_CorrectModesAOPtr
newCallback_IIFServer_CorrectModesAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_CorrectModesAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_CorrectModesAO.
 */
template<class T, typename CT> Callback_IIFServer_CorrectModesAOPtr
newCallback_IIFServer_CorrectModesAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_CorrectModesAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ModifyAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ModifyAO.
 */
template<class T>
class CallbackNC_IIFServer_ModifyAO : public Callback_IIFServer_ModifyAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ModifyAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ModifyAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ModifyAO.
 */
template<class T> Callback_IIFServer_ModifyAOPtr
newCallback_IIFServer_ModifyAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ModifyAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ModifyAO.
 */
template<class T> Callback_IIFServer_ModifyAOPtr
newCallback_IIFServer_ModifyAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ModifyAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ModifyAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ModifyAO.
 */
template<class T, typename CT>
class Callback_IIFServer_ModifyAO : public Callback_IIFServer_ModifyAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ModifyAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ModifyAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ModifyAO.
 */
template<class T, typename CT> Callback_IIFServer_ModifyAOPtr
newCallback_IIFServer_ModifyAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ModifyAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ModifyAO.
 */
template<class T, typename CT> Callback_IIFServer_ModifyAOPtr
newCallback_IIFServer_ModifyAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ModifyAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetAO.
 */
template<class T>
class CallbackNC_IIFServer_PresetAO : public Callback_IIFServer_PresetAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_PresetAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetAO.
 */
template<class T> Callback_IIFServer_PresetAOPtr
newCallback_IIFServer_PresetAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetAO.
 */
template<class T> Callback_IIFServer_PresetAOPtr
newCallback_IIFServer_PresetAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_PresetAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_PresetAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_PresetAO.
 */
template<class T, typename CT>
class Callback_IIFServer_PresetAO : public Callback_IIFServer_PresetAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_PresetAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_PresetAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetAO.
 */
template<class T, typename CT> Callback_IIFServer_PresetAOPtr
newCallback_IIFServer_PresetAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_PresetAO.
 */
template<class T, typename CT> Callback_IIFServer_PresetAOPtr
newCallback_IIFServer_PresetAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_PresetAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetXYAO.
 */
template<class T>
class CallbackNC_IIFServer_OffsetXYAO : public Callback_IIFServer_OffsetXYAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_OffsetXYAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetXYAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 */
template<class T> Callback_IIFServer_OffsetXYAOPtr
newCallback_IIFServer_OffsetXYAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetXYAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 */
template<class T> Callback_IIFServer_OffsetXYAOPtr
newCallback_IIFServer_OffsetXYAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetXYAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetXYAO.
 */
template<class T, typename CT>
class Callback_IIFServer_OffsetXYAO : public Callback_IIFServer_OffsetXYAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_OffsetXYAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetXYAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 */
template<class T, typename CT> Callback_IIFServer_OffsetXYAOPtr
newCallback_IIFServer_OffsetXYAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetXYAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetXYAO.
 */
template<class T, typename CT> Callback_IIFServer_OffsetXYAOPtr
newCallback_IIFServer_OffsetXYAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetXYAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetZAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetZAO.
 */
template<class T>
class CallbackNC_IIFServer_OffsetZAO : public Callback_IIFServer_OffsetZAO_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_OffsetZAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetZAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetZAO.
 */
template<class T> Callback_IIFServer_OffsetZAOPtr
newCallback_IIFServer_OffsetZAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetZAO<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetZAO.
 */
template<class T> Callback_IIFServer_OffsetZAOPtr
newCallback_IIFServer_OffsetZAO(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_OffsetZAO<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_OffsetZAO.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_OffsetZAO.
 */
template<class T, typename CT>
class Callback_IIFServer_OffsetZAO : public Callback_IIFServer_OffsetZAO_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_OffsetZAO(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_OffsetZAO(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetZAO.
 */
template<class T, typename CT> Callback_IIFServer_OffsetZAOPtr
newCallback_IIFServer_OffsetZAO(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetZAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_OffsetZAO.
 */
template<class T, typename CT> Callback_IIFServer_OffsetZAOPtr
newCallback_IIFServer_OffsetZAO(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_OffsetZAO<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference.
 */
template<class T>
class CallbackNC_IIFServer_SetReference : public Callback_IIFServer_SetReference_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference.
 */
template<class T> Callback_IIFServer_SetReferencePtr
newCallback_IIFServer_SetReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReference<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference.
 */
template<class T> Callback_IIFServer_SetReferencePtr
newCallback_IIFServer_SetReference(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReference<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference.
 */
template<class T, typename CT>
class Callback_IIFServer_SetReference : public Callback_IIFServer_SetReference_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference.
 */
template<class T, typename CT> Callback_IIFServer_SetReferencePtr
newCallback_IIFServer_SetReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference.
 */
template<class T, typename CT> Callback_IIFServer_SetReferencePtr
newCallback_IIFServer_SetReference(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReferenceNew.
 */
template<class T>
class CallbackNC_IIFServer_SetReferenceNew : public Callback_IIFServer_SetReferenceNew_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetReferenceNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReferenceNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 */
template<class T> Callback_IIFServer_SetReferenceNewPtr
newCallback_IIFServer_SetReferenceNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReferenceNew<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 */
template<class T> Callback_IIFServer_SetReferenceNewPtr
newCallback_IIFServer_SetReferenceNew(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReferenceNew<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReferenceNew.
 */
template<class T, typename CT>
class Callback_IIFServer_SetReferenceNew : public Callback_IIFServer_SetReferenceNew_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetReferenceNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReferenceNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 */
template<class T, typename CT> Callback_IIFServer_SetReferenceNewPtr
newCallback_IIFServer_SetReferenceNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReferenceNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReferenceNew.
 */
template<class T, typename CT> Callback_IIFServer_SetReferenceNewPtr
newCallback_IIFServer_SetReferenceNew(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReferenceNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference2.
 */
template<class T>
class CallbackNC_IIFServer_SetReference2 : public Callback_IIFServer_SetReference2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_SetReference2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReference2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference2.
 */
template<class T> Callback_IIFServer_SetReference2Ptr
newCallback_IIFServer_SetReference2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReference2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference2.
 */
template<class T> Callback_IIFServer_SetReference2Ptr
newCallback_IIFServer_SetReference2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_SetReference2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_SetReference2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_SetReference2.
 */
template<class T, typename CT>
class Callback_IIFServer_SetReference2 : public Callback_IIFServer_SetReference2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_SetReference2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_SetReference2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference2.
 */
template<class T, typename CT> Callback_IIFServer_SetReference2Ptr
newCallback_IIFServer_SetReference2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReference2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_SetReference2.
 */
template<class T, typename CT> Callback_IIFServer_SetReference2Ptr
newCallback_IIFServer_SetReference2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_SetReference2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearReference.
 */
template<class T>
class CallbackNC_IIFServer_ClearReference : public Callback_IIFServer_ClearReference_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_ClearReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearReference.
 */
template<class T> Callback_IIFServer_ClearReferencePtr
newCallback_IIFServer_ClearReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearReference<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearReference.
 */
template<class T> Callback_IIFServer_ClearReferencePtr
newCallback_IIFServer_ClearReference(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_ClearReference<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_ClearReference.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_ClearReference.
 */
template<class T, typename CT>
class Callback_IIFServer_ClearReference : public Callback_IIFServer_ClearReference_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_ClearReference(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_ClearReference(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearReference.
 */
template<class T, typename CT> Callback_IIFServer_ClearReferencePtr
newCallback_IIFServer_ClearReference(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_ClearReference.
 */
template<class T, typename CT> Callback_IIFServer_ClearReferencePtr
newCallback_IIFServer_ClearReference(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_ClearReference<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates.
 */
template<class T>
class CallbackNC_IIFServer_GetKFPCoordinates : public Callback_IIFServer_GetKFPCoordinates_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetKFPCoordinates(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinates(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 */
template<class T> Callback_IIFServer_GetKFPCoordinatesPtr
newCallback_IIFServer_GetKFPCoordinates(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinates<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 */
template<class T> Callback_IIFServer_GetKFPCoordinatesPtr
newCallback_IIFServer_GetKFPCoordinates(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinates<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates.
 */
template<class T, typename CT>
class Callback_IIFServer_GetKFPCoordinates : public Callback_IIFServer_GetKFPCoordinates_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetKFPCoordinates(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinates(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinatesPtr
newCallback_IIFServer_GetKFPCoordinates(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinates<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinatesPtr
newCallback_IIFServer_GetKFPCoordinates(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinates<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinatesNew.
 */
template<class T>
class CallbackNC_IIFServer_GetKFPCoordinatesNew : public Callback_IIFServer_GetKFPCoordinatesNew_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetKFPCoordinatesNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinatesNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 */
template<class T> Callback_IIFServer_GetKFPCoordinatesNewPtr
newCallback_IIFServer_GetKFPCoordinatesNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinatesNew<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 */
template<class T> Callback_IIFServer_GetKFPCoordinatesNewPtr
newCallback_IIFServer_GetKFPCoordinatesNew(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinatesNew<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinatesNew.
 */
template<class T, typename CT>
class Callback_IIFServer_GetKFPCoordinatesNew : public Callback_IIFServer_GetKFPCoordinatesNew_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetKFPCoordinatesNew(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinatesNew(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinatesNewPtr
newCallback_IIFServer_GetKFPCoordinatesNew(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinatesNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinatesNew.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinatesNewPtr
newCallback_IIFServer_GetKFPCoordinatesNew(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinatesNew<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates2.
 */
template<class T>
class CallbackNC_IIFServer_GetKFPCoordinates2 : public Callback_IIFServer_GetKFPCoordinates2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_GetKFPCoordinates2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinates2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 */
template<class T> Callback_IIFServer_GetKFPCoordinates2Ptr
newCallback_IIFServer_GetKFPCoordinates2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinates2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 */
template<class T> Callback_IIFServer_GetKFPCoordinates2Ptr
newCallback_IIFServer_GetKFPCoordinates2(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_GetKFPCoordinates2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_GetKFPCoordinates2.
 */
template<class T, typename CT>
class Callback_IIFServer_GetKFPCoordinates2 : public Callback_IIFServer_GetKFPCoordinates2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_GetKFPCoordinates2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_GetKFPCoordinates2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinates2Ptr
newCallback_IIFServer_GetKFPCoordinates2(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinates2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_GetKFPCoordinates2.
 */
template<class T, typename CT> Callback_IIFServer_GetKFPCoordinates2Ptr
newCallback_IIFServer_GetKFPCoordinates2(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_GetKFPCoordinates2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_NSQuery.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_NSQuery.
 */
template<class T>
class CallbackNC_IIFServer_NSQuery : public Callback_IIFServer_NSQuery_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const result&);

    CallbackNC_IIFServer_NSQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_NSQuery(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_NSQuery.
 */
template<class T> Callback_IIFServer_NSQueryPtr
newCallback_IIFServer_NSQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_NSQuery<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_NSQuery.
 */
template<class T> Callback_IIFServer_NSQueryPtr
newCallback_IIFServer_NSQuery(T* instance, void (T::*cb)(const result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_NSQuery<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_NSQuery.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_NSQuery.
 */
template<class T, typename CT>
class Callback_IIFServer_NSQuery : public Callback_IIFServer_NSQuery_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const result&, const CT&);

    Callback_IIFServer_NSQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        IIFServerPrx proxy = IIFServerPrx::uncheckedCast(result->getProxy());
        result ret;
        try
        {
            ret = proxy->end_NSQuery(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_NSQuery.
 */
template<class T, typename CT> Callback_IIFServer_NSQueryPtr
newCallback_IIFServer_NSQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_NSQuery<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_NSQuery.
 */
template<class T, typename CT> Callback_IIFServer_NSQueryPtr
newCallback_IIFServer_NSQuery(T* instance, void (T::*cb)(const result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_NSQuery<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::lbto::IIFServer::begin_remove.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_remove.
 */
template<class T>
class CallbackNC_IIFServer_remove : public Callback_IIFServer_remove_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_IIFServer_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_remove<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_remove<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_remove<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_IIFServer_remove<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::lbto::IIFServer::begin_remove.
 * Create a wrapper instance by calling ::lbto::newCallback_IIFServer_remove.
 */
template<class T, typename CT>
class Callback_IIFServer_remove : public Callback_IIFServer_remove_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_IIFServer_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T, typename CT> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_remove<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T, typename CT> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_remove<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T, typename CT> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_remove<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::lbto::IIFServer::begin_remove.
 */
template<class T, typename CT> Callback_IIFServer_removePtr
newCallback_IIFServer_remove(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_IIFServer_remove<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
