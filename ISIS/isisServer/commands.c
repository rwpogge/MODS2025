//
// commands.c - ISISI server command functions.
//
// Contents:
// --------
//   int isisCommand() - main ISIS command handler
//   int serverInfo()  - report concise server status
//   void printHelp()  - print a quick summary of ISIS commands
//   void printInfo()  - report detailed server info
//   void portInfo()   - report serial port info
//
// R. Pogge, OSU Astronomy Dept.
// pogge@astronomy.ohio-state.edu
// 2003 January 4
//
// Modification History:
//   2003 Jan 15: bug fixes and added new commands [rwp/osu]
//   2005 Aug 08: removed confusing Inst= from CONFIG [rwp/osu]
//   2009 Mar 18: updates for v2 [rwp/osu]
//

#include "isisserver.h"

/*!
  \file commands.c
  \brief ISIS server command functions.

  These functions are used for processing ISIS server commands.

  ... more to come ...

*/

//---------------------------------------------------------------------------
//
// isisCommand() 
//

/*!
  \brief Process an ISIS server command.
  \param cmdStr String with command and arguments to process.
  \param replyStr  String to hold any reply generated by \c cmdStr

  \return #MSG_REPLY if command generates a reply message to the
  caller #MSG_NOOP if command does not require a reply or an error
  occurred #MSG_ECHO if the entire message, including address header,
  is to be echoed to stdout.

  The individual command actions are encapsulated in this routine, except
  for serverInfo() - someday we'll do this in a less hacky fashion.

*/

int
isisCommand(char *cmdStr, char *replyStr)
{
  char cmdWord[SHORT_STR_SIZE];  // command verb    
  char cmdArgs[MED_STR_SIZE];     // argument buffer
  int  iport;
  int  i;
  char tstr[32];
  int  isExec = 0;
  char errStr[MED_STR_SIZE];

  // UDP Socket Communications

  struct sockaddr_in client;  // Network client socket info   
  int clientLen;       
  int numSent;
  char ipAddr[MED_STR_SIZE];
  int  ipPort;
  char pingStr[MED_STR_SIZE];

  // The first word in the command string must be the command verb 

  getArg(cmdStr,1,cmdWord);

  // First check to see if this is an IMPv2-compliant message 
  // 
  // If the message is one of:
  //   DONE: or STATUS:, instruct the calling routine to echo the entire
  //                     message, including addressing.
  //   ERROR:, WARNING:, FATAL:, print a BELL character, then echo.

  if (strcasecmp(cmdWord,"STATUS:")==0 ||
      strcasecmp(cmdWord,"DONE:")==0) {

    return(MSG_ECHO);

  }
  else if (strcasecmp(cmdWord,"ERROR:")==0 ||
	   strcasecmp(cmdWord,"WARNING:")==0 ||
	   strcasecmp(cmdWord,"FATAL:")==0) {
    
    return(MSG_ECHO);

  }
  else if (strcasecmp(cmdWord,"EXEC:")==0) {
    isExec = 1;
    getArg(cmdStr,2,cmdWord);
  }
  else
    isExec = 0;


  // We have an ISIS command (REQ: or EXEC: including implicit REQ:),
  // process it

  // Communications Handshaking & Control

  // PING: communications initialization request
  //       Respond back with "PONG" 

  if (strcasecmp(cmdWord,"PING")==0) {
    sprintf(replyStr,"PONG");
    return(MSG_REPLY);

  }
  
  // PONG: communications initialization acknowledgment.
  //       No response required, echo message to screen
   
  else if (strcasecmp(cmdWord,"PONG")==0) {
    return(MSG_ECHO);

  }

  // QUIT: kill the server, but only if preceeded by EXEC:

  else if (strcasecmp(cmdWord,"QUIT")==0) {
    if (isExec) {
      isis.keepGoing = 0;
      sprintf(replyStr,"DONE: QUIT ISIS executive quit command executed %s=OFFLINE",
              isis.serverID);
      if (!isis.useCLI)
	logMessage("Executive server shutdown request received");
    }
    else {
      sprintf(replyStr,"ERROR: QUIT can only be executed as an executive override command");
    }
    return(MSG_REPLY);
  }
    
  // RESTART: request to restart server, pass it 
   
  else if (strcasecmp(cmdWord,"RESTART")==0) {
    sprintf(replyStr,"ERROR: RESTART command not yet implemented");
    return(MSG_REPLY);

  }

  // FLUSH: flush a serial port
  //
  // usage: FLUSH n  
  //
  // where n is the port number [0..MAXSERIAL-1]
   
  else if (strcasecmp(cmdWord,"FLUSH")==0) {
    getArg(cmdStr,2+isExec,cmdArgs);
    if (strlen(cmdArgs)==0) {
      sprintf(replyStr,"ERROR: FLUSH must specify port to flush");
      return(MSG_REPLY);
    }
    iport = atoi(cmdArgs);
    if (iport < 0 || iport >= MAXSERIAL) {
      sprintf(replyStr,"ERROR: FLUSH port %d out of range [0-%d]",iport,MAXSERIAL-1);
      return(MSG_REPLY);
    }
    if (ttyTab[iport].fd > 0) {
      tcflush(ttyTab[iport].fd,TCIOFLUSH);
      sprintf(replyStr,"DONE: FLUSH serial port %d (%s) flushed",iport,
	      ttyTab[iport].devName);
    } 
    else {
      sprintf(replyStr,"ERROR: FLUSH serial port %d not enabled",iport);
    }
    return(MSG_REPLY);

  }

  // REMOVE: remove a host from the client table
  //
  // usage: REMOVE xx
  //
  // removes host xx from the table, if present 
   
  else if (strcasecmp(cmdWord,"REMOVE")==0) {
    getArg(cmdStr,2+isExec,cmdArgs);
    upperCase(cmdArgs);
    if (strlen(cmdArgs)==0) {
      sprintf(replyStr,"ERROR: REMOVE Must specify host to remove");
      return(MSG_REPLY);
    }
    if (removeHost(cmdArgs) == 0)
      sprintf(replyStr,"DONE: REMOVE Host %s removed from the host table",cmdArgs);
    else
      sprintf(replyStr,"ERROR: REMOVE Host %s unknown, not removed",cmdArgs);

    return(MSG_REPLY);

  }

  // General Commands

  // VERSION: return current server version information
   
  else if (strcasecmp(cmdWord,"VERSION")==0) {
    sprintf(replyStr,
       "DONE: VERSION Version='%s' exeName=%s rcFile=%s UserID=%s CompDate=%s CompTime=%s",
	    ISIS_VERSION,isis.exeFile,isis.iniFile,
	    isis.userID,ISIS_COMPDATE,ISIS_COMPTIME);
    return(MSG_REPLY);

  }

  // STATUS: report concise server status 
   
  else if (strcasecmp(cmdWord,"STATUS")==0) {
    serverInfo(replyStr);
    return(MSG_REPLY);

  }

  // HOST: report information about the one or more hosts
   
  else if (strcasecmp(cmdWord,"HOST")==0) {
    getArg(cmdStr,2+isExec,cmdArgs);
    if (strlen(cmdArgs)==0) 
      strcpy(cmdArgs,"all");
    hostInfo(cmdArgs,replyStr);
    return(MSG_REPLY);

  }

  // LOG: report the name of the current runtime log

  else if (strcasecmp(cmdWord,"LOG")==0) {
    sprintf(replyStr,"DONE: LOG logFile=%s",isis.logFile);
    return(MSG_REPLY);

  }

  // HOSTS: alias for HOST ALL
   
  else if (strcasecmp(cmdWord,"HOSTS")==0) {
    strcpy(cmdArgs,"ALL");
    hostInfo(cmdArgs,replyStr);
    return(MSG_REPLY);

  }

  // UDPPING: Ping the named UDP socket port
  // Usage: UDPPING ipAddr ipPort
  //

  else if (strcasecmp(cmdWord,"UDPPING")==0) {
    client.sin_family = AF_INET;
    getArg(cmdStr,2+isExec,ipAddr);
    if (strlen(ipAddr)<=0) {
      strcpy(replyStr,"ERROR: UDPPING Blank IP address or port");
      return(MSG_REPLY);
    }
    if (inet_pton(AF_INET,ipAddr,&client.sin_addr)<=0) {
      sprintf(replyStr,"ERROR: UDPPING Invalid IPAddress '%s'",ipAddr);
      return(MSG_REPLY);
    }
    getArg(cmdStr,3+isExec,cmdArgs);
    ipPort = atoi(cmdArgs);
    client.sin_port = htons(ipPort) ;
    clientLen = sizeof(client);
    sprintf(pingStr,"%s>AL PING\r",isis.serverID);
    numSent = sendto(isis.sockFD,pingStr,strlen(pingStr),0, 
		     (struct sockaddr *) &client, clientLen);
    if (numSent < strlen(pingStr)) {
      sprintf(errStr,"ERROR: UDPPING socket sendto() Error to %s:%d - %s\n",
	      ipAddr,ipPort,strerror(errno));
      if (isis.useCLI)
	printf("%s\n",errStr);
      else
	logMessage(errStr);
      
      sprintf(replyStr,"ERROR: UDPPING Cannot Ping %s:%d - %s",ipAddr,ipPort,strerror(errno));
      return(MSG_REPLY);
    }
    sprintf(replyStr,"DONE: UDPPING Sent PING to %s:%d",ipAddr,ipPort);
    return(MSG_REPLY);
  }

  // PORTS: list all hardware (serial) ports
   
  else if (strcasecmp(cmdWord,"PORTS")==0) {
    portInfo(replyStr);
    return(MSG_REPLY);

  }

  // TIME: read system clock and report system UTC date/time to caller
  //       Date in CCYY-MM-DD format, Time in hh:mm:ss (ISO-8601), and
  //       the time system as standard FITS keywords.
   
  else if (strcasecmp(cmdWord,"TIME")==0) {
    getUTCTime();
    sprintf(replyStr,"DONE: TIME DATE=%s TIME=%s ISODATE=%s TIMESYS=UTC",
	    isis.utcDate,isis.utcTime,getDateTime());
    return(MSG_REPLY);

  }

  // CONFIG: report the system configuration
  //         which hosts are "enabled" and the instrument if we
  //         know it.  [Inst= removed 2005-Aug-08 rwp/osu]
   
  else if (strcasecmp(cmdWord,"CONFIG")==0) {
    if (isis.numClients == 0) {
      strcpy(replyStr,"DONE: CONFIG NumClients=0");
    } else {
      strcpy(replyStr,"DONE: CONFIG ");
      for (i=0; i<MAXCLIENTS; i++) {
	if (clientTab[i].method != UNASSIGNED) {
	  sprintf(tstr,"%s=ENABLED ",clientTab[i].ID);
	  strcat(replyStr,tstr);
	}
      }
    }
    return(MSG_REPLY);
    
  }

  // Unknown command, reply with an error message

  else {
    sprintf(replyStr,"ERROR: Unrecognized ISIS command - %s",cmdWord);
    return(MSG_REPLY);

  } 

  // end of the command decision tree 
      
}

//---------------------------------------------------------------------------

/*!
  \brief Report consise server status as an IMPv2-compliant message
  \param replyStr String to contain the server status message

  \return #MSG_REPLY (never returns an error).

  Creates an IMPv2-compliant string with a summary of the current
  server status.  Meant to be sent back as a DONE: or STATUS: type
  message to the client who requested the info.

*/

int 
serverInfo(char *replyStr)
{
  sprintf(replyStr,
	  "DONE: STATUS HostName=%s HostAddr=%s:%d rcFile=%s logFile=%s numClients=%d %s %s %s %s\n",
	  isis.serverID,\
	  isis.localHost,isis.sockPort,
	  isis.iniFile,
	  isis.logFile,
	  isis.numClients,
	  ((isis.isVerbose) ? "Verbose":"Concise"),
	  ((isis.doLogging) ? "+LOG":"-LOG"),
	  ((isis.doHandShaking) ? "+HANDSHAKE" : "-HANDSHAKE"),
	  ((isis.useCLI) ? "+CLI" : "-CLI"));

  // add stuff as required... 

  return(MSG_REPLY);

}

//---------------------------------------------------------------------------
//
// printHelp()
//

/*!
  \brief Print a quick summary of ISIS server commands to the console.

  Prints the current command list to the console intended as an
  aide-memoire, not a proper help utility.  Don't expect much from it
  (besides, the command set is SMALL, that's the idea).
*/

void
printHelp()
{
  if (!isis.useCLI) return;
  printf("\nServer Command Summary:\n");
  printf(" Executive Commands (keyboard-only):\n");
  printf("    QUIT      Terminate the server session and exit\n");
  printf("    HOSTS     Print a table of all currently known client hosts on the screen\n");
  printf("    INFO      Display detailed server information on the screen\n");
  printf("    HELP      List of server commands\n");
  printf("    VERBOSE   Echo all server communications to the screen\n");
  printf("    CONCISE   Suppress echoing of communications (opposite of VERBOSE)\n");
  printf("    HISTORY   List recently typed commands (like Unix history)\n");
  printf(" Communications Control:\n");
  printf("    PING      Communications initialization request, responds with a PONG \n");
  printf("    PONG      Communications initialization acknowledge, no response required\n");
  printf("    RESTART   Warm restart the server, clear runtime tables, PING fixed ports\n");
  printf("    PORTS     lists the active tty ports\n");
  printf("    FLUSH n   Flush tty port n of junk\n");
  printf("    REMOVE xx Remove host xx from the client host table\n");
  printf("    UDPPING ip port Ping the named UDP socket port\n");
  printf(" Utilities\n");
  printf("    VERSION   Return program version info\n");
  printf("    HOST xx   Return info on a client host xx (or xx=all)\n");
  printf("    STATUS    Return a server status message\n");
  printf("    CONFIG    Displays current configuration with instrument info\n");
  printf("    TIME      Report the UTC time and date as FITS-like keywords\n");
  printf("    -LOG      Disable the server's runtime log temporarily\n");
  printf("    +LOG      (Re)Enable the server's runtime log after -LOG\n");
  printf("\n");
  return;
}

//---------------------------------------------------------------------------
//
// printInfo()
//

/*!
  \brief Report detailed server info on server console (stdout)

  printInfo() makes a detailed, formatted report of the current
  server status on stdout.  

  For generic, concise info services, see serverInfo().
*/

void
printInfo()
{
  if (!isis.useCLI) return;
  char inetstr[INET6_ADDRSTRLEN];
  struct sockaddr_in client;
  int i;

  // Basic Server Information 

  printf("\nServer Information:\n");
  printf("  HostID: %s\n",isis.serverID);
  printf("  IPAddr: %s:%d\n",isis.localHost,isis.sockPort);
  printf("  rcFile: %s\n",isis.iniFile);
  printf(" logFile: %s\n",isis.logFile);
  printf("Server Status:\n");
  printf("  Started by user '%s' at %s\n",isis.userID,isis.startTime);

  // Give information about the ISIS clients 

  if (isis.numClients == 0) {
    printf("  No clients connected (%d max)\n",MAXCLIENTS);
  }
  else {
    printf("  Clients: %d of %d max\n",isis.numClients,MAXCLIENTS);
    for (i=0; i<MAXCLIENTS; i++) {
      switch(clientTab[i].method) {
      case SERIAL:
	printf("    %s: TTY %s\n",clientTab[i].ID,
	       ttyTab[clientTab[i].port].devName);
	break;

      case SOCKET:
	client.sin_family = AF_INET;
	client.sin_addr.s_addr = htonl(clientTab[i].addr) ;
	client.sin_port = htons(clientTab[i].port) ;
	printf("    %s: UDP %s:%d\n",clientTab[i].ID,
	       inet_ntop(client.sin_family,&client.sin_addr,inetstr,
			 sizeof(inetstr)),clientTab[i].port);
	break;

      default:
	break;

      } // end of method switch 
    }
  }

  // Serial Ports 

  if (isis.numSerial == 0) {
    printf("  No Serial Ports configured\n");
  }
  else {
    printf("  Serial Ports: %d configured of %d max:\n",
	   isis.numSerial,MAXSERIAL);
    for (i=0;i<isis.numSerial;i++) {
      printf("    tty%d: %s\n",i,ttyTab[i].devName);
    }
  }

  // Preset UDP Ports

  if (isis.numPreset == 0) {
    printf("  No Preset UDP Ports configure\n");
  }
  else {
    printf("  Preset UDP Ports: %d configured of %d max:\n",
	   isis.numPreset,MAXPRESET);
    for (i=0;i<isis.numPreset;i++) {
      printf("    udp%d: %s:%d\n",i,udpTab[i].host,udpTab[i].port);
    }
  }

  // runtime flags 

  printf("  Flags: ");
  if (isis.isVerbose) 
    printf("VERBOSE ");
  else
    printf("CONCISE ");
  
  if (isis.doLogging)
    printf("+LOG ");
  else
    printf("-LOG ");

  if (isis.doHandShaking)
    printf("+HANDSHAKING ");
  else
    printf("-HANDSHAKING ");

  printf("\n");

  // Instrument Config info 

  printf("Instrument Config: %s\n",isis.instID);

  // Version information and other info as required 

  printf("Executable: %s\n  Version: %s\n  Compiled on %s at %s\n\n",
	 isis.exeFile,ISIS_VERSION,ISIS_COMPDATE,ISIS_COMPTIME);

  // all done, return 

  return;

}

/*!
  \brief Create a string with the server's serial port table info.
  \param replyStr String to hold the serial port table summary

  Create a string with as summary of the current serial ports
  in IMPv2-compliant format suitable for transmission to an ISIS client.
*/

void 
portInfo(char *replyStr)
{
  int i;

  if (isis.numSerial <= 0) {
    sprintf(replyStr,"DONE: PORTS No serial ports connected.");
    return;
  }

  // Generate the serial port list ...

  sprintf(replyStr,"DONE: PORTS NumSerial=%d MaxSerial=%d",isis.numSerial,
	  MAXSERIAL);
  for (i=0; i<isis.numSerial; i++)
    sprintf(replyStr,"%s tty%d=%s",replyStr,i,ttyTab[i].devName);

  // ... and the preset UDP port list.

  sprintf(replyStr,"%s NumPreset=%d MaxPreset=%d",replyStr,
	  isis.numPreset,MAXPRESET);
  for (i=0; i<isis.numPreset; i++)
    sprintf(replyStr,"%s udp%d=%s:%d",replyStr,
	    i,udpTab[i].host,udpTab[i].port);

  return;

}
